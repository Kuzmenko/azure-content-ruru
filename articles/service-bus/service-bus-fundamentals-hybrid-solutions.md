<properties 
	pageTitle="Служебная шина Azure | Microsoft Azure" 
	description="Общие сведения об использовании служебной шины для подключения приложений Azure к другим программам." 
	services="service-bus" 
	documentationCenter=".net" 
	authors="sethmanheim" 
	manager="timlt" 
	editor=""/>

<tags 
	ms.service="service-bus" 
	ms.workload="na" 
	ms.tgt_pltfrm="na" 
	ms.devlang="na" 
	ms.topic="get-started-article" 
	ms.date="08/31/2016" 
	ms.author="sethm"/>

# Azure Service Bus

Независимо от того, работают ли приложение или служба в облаке или локально, они часто должны взаимодействовать с другими приложениями или службами. Для обеспечения этой возможности Microsoft Azure предлагает Service Bus. В данной статье приводится обзор, описание и сценарии использования этой технологии.

## Базовая информация о Service Bus

В разных ситуациях требуются разные способы взаимодействия. Иногда лучшим решением является обмен сообщениями между приложениями через простую очередь. В других ситуациях обычной очереди недостаточно и лучше использовать очередь с механизмом публикации и подписки. В некоторых случаях необходимо лишь подключение между приложениями, а очередь не требуется. Служебная шина предлагает все три варианта, позволяя приложениям взаимодействовать несколькими разными способами.

Service Bus — это мультитенантная облачная служба, т. е. служба, совместно используемая несколькими пользователями. Каждый пользователь, например разработчик приложений, создает *пространство имен* и определяет механизмы взаимодействия, которые должны использоваться в нем. Рисунок 1 демонстрирует, как это выглядит.

![][1]
 
**Рис. 1. Служебная шина предоставляет мультитенантную службу для связи приложений через облако**

В рамках пространства имен можно использовать один или несколько экземпляров четырех механизмов взаимодействия, по-разному связывающих приложения. Возможны следующие варианты:

- *Очереди*, которые поддерживают однонаправленное взаимодействие. Каждая очередь действует как посредник (иногда называемый *брокером*), который хранит отправленные сообщения, пока они не будут получены. Каждое сообщение получает один получатель.
- *Разделы*, которые поддерживают однонаправленное взаимодействие с использованием *подписок*. В одном разделе может быть несколько подписок. Подобно очереди, раздел действует как брокер, но каждая подписка может при необходимости применить фильтр, чтобы получать только те сообщения, которые соответствуют определенным условиям.
- *Ретрансляторы*, которые обеспечивают двунаправленное взаимодействие. В отличие от очередей и разделов ретранслятор не хранит передаваемые сообщения, так как не является брокером. Он просто передает сообщения целевым приложениям.

При создании очереди, раздела или ретранслятора задается имя. В комбинации с именем пространства имен это имя создает уникальный идентификатор объекта. Приложения могут передать это имя службе Service Bus, а затем использовать соответствующую очередь, раздел или ретранслятор для взаимодействия с другими приложениями.

Приложения Windows могут использовать эти объекты в сценарии ретрансляции с помощью Windows Communication Foundation (WCF). Для очередей и разделов приложения Windows могут использовать API-интерфейсы для обмена сообщениями, определяемые служебной шиной. Чтобы упростить использование этих объектов из приложений сторонних разработчиков, Майкрософт предлагает пакеты SDK для Java, Node.js и других языков. К очередям и разделам можно получить доступ также с помощью интерфейсов REST API через HTTP (HTTPS).

Важно понимать, что хотя служебная шина и работает в облаке (т. е. в центрах обработки данных Microsoft Azure), использующие ее приложения могут работать где угодно. С помощью служебной шины можно связать приложения, выполняемые, например, в Azure и в локальном центре обработки данных. Эту службу также можно использовать для связи приложения, работающего в Azure или на другой облачной платформе, с локальным приложением или с планшетами и телефонами. Можно даже связывать бытовые приборы, датчики и другие устройства с центральным приложением или друг с другом. Служебная шина — это механизм взаимодействия в облаке, доступный практически везде. Способ ее использования зависит от целей приложения.

## Очереди

Предположим, вам необходимо связать два приложения с помощью очереди служебной шины. Эта ситуация показана на рисунке 2.

![][2]
 
**Рис. 2. Очереди служебной шины обеспечивают однонаправленное асинхронное взаимодействие**

Процесс прост: отправитель отправляет сообщение в очередь Service Bus, а получатель извлекает это сообщение позднее. В очереди может быть только один получатель, как показано на рис. 2, или несколько приложений могут считывать данные одной очереди. В последнем случае каждое сообщение считывает только один получатель. А для службы многоадресной рассылки следует использовать раздел.

Каждое сообщение состоит из двух частей: набора свойств (пар ключ/значение) и двоичного тела сообщения. Способ их использования зависит от целей приложения. Например, приложение, отправляющее сообщение о недавней продаже, может включить в него свойства *Seller="Ava"* and *Amount=10000*. Тело сообщения может содержать отсканированное изображение подписанного контракта или может остаться пустым.

Получатель может считать сообщение из очереди Service Bus двумя способами. Первый способ, *ReceiveAndDelete*, извлекает сообщение из очереди и сразу удаляет его. Это простой способ, но если у получателя произойдет сбой до того как он завершит обработку сообщения, оно будет потеряно. Поскольку сообщение было удалено из очереди, другие получатели не смогут прочитать его.

Второй способ, *PeekLock*, направлен на решение этой проблемы. Как и **ReceiveAndDelete**, считывание **PeekLock** извлекает сообщение из очереди. Однако он не удаляет сообщение. Вместо этого он блокирует сообщение, делая его невидимым для других получателей, а затем ожидает одно из трех событий:

- если получатель успешно обрабатывает сообщение, вызывается функция **Complete** и очередь удаляет сообщение;
- если получатель не может обработать сообщение, вызывается функция **Abandon**; Тогда очередь разблокирует сообщение и делает его доступным для других получателей.
- Если получатель не вызывает ни одну из этих функций в течение заданного периода времени (по умолчанию 60 секунд), очередь считает, что получателю не удалось обработать сообщение. В этом случае очередь делает сообщение доступным для других получателей, как при вызове функции **Abandon**.

Обратите внимание, что может произойти: одно и то же сообщение может быть доставлено дважды, возможно, двум разным получателям. Приложения, использующие очереди Service Bus, должны быть готовы к этому. Чтобы упростить поиск повторяющихся данных, каждому сообщению задается уникальное свойство **MessageID**, которое по умолчанию не изменяется, независимо от того, сколько раз сообщение считывается из очереди.

Очереди полезны во многих ситуациях. Они позволяют приложениям взаимодействовать, даже если эти приложения работают не одновременно. Это особенно удобно при использовании пакетных и мобильных приложений. Очередь с несколькими получателями обеспечивает автоматическую балансировку нагрузки, так как отправленные сообщения распределяются между получателями.

## Разделы

Хотя очереди удобны, они не всегда являются правильным выбором. Иногда лучше использовать разделы служебной шины. Рисунок 3 иллюстрирует принцип работы разделов.

![][3]
 
**Рис. 3. Подписанное приложение определяет фильтр, на основании которого оно может получать некоторые или все сообщения, отправленные в раздел служебной шины**

*Разделы* во многом похожи на очереди. Отправители отправляют сообщения в раздел так же, как в очередь, и эти сообщения выглядят в разделе так же, как в очереди. Существенное отличие заключается в том, что разделы позволяют каждому принимающему приложению создавать собственную *подписку*, определив *фильтр*. Подписчик будет видеть только те сообщения, которые соответствуют фильтру. Например, на рисунке 3 показан отправитель и раздел с тремя подписчиками, у каждого из которых имеется собственный фильтр:

- Подписчик 1 получает только сообщения, содержащие свойство *Seller="Ava"*.
- Подписчик 2 получает сообщения, содержащие свойства *Seller="Ruby"* и *Amount* со значением больше 100 000. Возможно, Ruby — это продавец, который хочет просматривать свои собственные продажи и крупные продажи независимо от того, кто их осуществил.
- Подписчик 3 задал для фильтра значение *True*, которое означает, что он получает все сообщения. Это приложение может, к примеру, вести журнал аудита, и поэтому ему нужен доступ ко всем сообщениям.

Как и подписчики очередей, подписчики разделов могут считывать сообщения с помощью методов **ReceiveAndDelete** и **PeekLock**. Однако отдельное сообщение, отправленное в раздел (в отличие от очереди), может быть получено несколькими подписками. Такой подход, обычно называемый *публикация и подписка* (или *pub/sub*), используется, когда несколько приложений ожидают одни и те же сообщения. Правильно определив фильтр, каждый подписчик может получить доступ лишь к той части потока сообщений, которая ему необходима.

## Ретрансляторы

Очереди и разделы обеспечивают однонаправленное асинхронное взаимодействие через брокер. Трафик протекает только в одном направлении, и между отправителями и получателями нет прямой связи. Но что делать, если требуется другой механизм? Предположим, что вашим приложениям нужно и отправлять, и получать сообщения или необходима прямая связь между приложениями, а посредник для хранения сообщений не требуется. Для таких случаев в служебной шине есть *ретрансляторы*, как показано на рисунке 4.

![][4]
 
**Рис. 4. Ретранслятор служебной шины обеспечивает синхронное двунаправленное взаимодействие между приложениями**

В каких случаях используются ретрансляторы? Даже если очереди не нужны, почему бы приложениям взаимодействовать не через облачную службу, а напрямую? Дело в том, что организовать прямой обмен сообщениями сложнее, чем кажется.

Предположим, нужно связать два локальных приложения, которые выполняются в корпоративных центрах обработки данных. Каждое из этих приложений находится за брандмауэром, а центры обработки данных могут использовать преобразование сетевых адресов (NAT). Брандмауэр блокирует входящие данные на всех портах кроме нескольких, а вследствие действия NAT компьютеры, на которых работают приложения, не имеют фиксированных IP-адресов, к которым можно получить непосредственный доступ за пределами центра обработки данных. Без дополнительных средств эти приложения непросто связать через общедоступный Интернет.

Ретранслятор служебной шины Azure может помочь в этом. Для двунаправленного взаимодействия через ретранслятор каждое приложение устанавливает исходящее TCP-соединение с Service Bus и держит его открытым. Весь обмен данными между двумя приложениями проходит через эти соединения. Так как каждое соединение установлено из центра обработки данных, брандмауэр разрешает входящий трафик для каждого приложения без открытия новых портов. Этот подход также решает проблему NAT, так как каждое приложение имеет постоянную конечную точку в облаке на протяжении всего обмена данными. Обмениваясь данными через ретранслятор, приложения могут избежать проблем, которые в противном случае осложнили бы взаимодействие.

Приложения могут использовать ретрансляторы служебной шины с помощью Windows Communication Foundation (WCF). Service Bus предоставляет привязки WCF, которые упрощают взаимодействие приложений Windows через ретрансляторы. Приложения, которые уже используют WCF, могут просто указать одну из этих привязок и обмениваться данными через ретранслятор. В отличие от использования очередей и разделов, использование ретрансляторов из приложений, работающих не под управлением Windows, хотя и возможно, но требует дополнительных усилий программистов, так как стандартные библиотеки не предусмотрены.

В отличие от очередей и разделов, приложения не создают ретрансляторы явно. Когда приложение, которое собирается получать сообщения, устанавливает TCP-соединение с Service Bus, ретранслятор создается автоматически. Когда соединение разрывается, ретранслятор удаляется. Чтобы приложение могло найти ретранслятор, созданный конкретным прослушивателем, служебная шина предоставляет реестр, который позволяет приложениям найти конкретный ретранслятор по имени.

Ретрансляторы являются оптимальным решением, когда требуется прямое взаимодействие между приложениями. Например, система бронирования авиабилетов, работающая в локальном центре обработки данных, к которой должен осуществляться доступ из киосков регистрации, с мобильных устройств и с других компьютеров. Приложения, работающие во всех этих системах, могут взаимодействовать через ретрансляторы Service Bus в облаке, где бы они ни находились.

## Сводка

Подключение приложений всегда было частью создания полноценных решений. Диапазон сценариев, для которых требуется взаимодействие между приложениями и службами, будет расти по мере подключения все большего количества приложений и устройств к Интернету. При предоставлении облачных технологий с помощью очередей, разделов и ретрансляторов используется служебная шина, которая упрощает эту важную функцию и делает ее более доступной.

## Дальнейшие действия

Вы познакомились с основами служебной шины Azure, используйте следующие ссылки для получения дополнительных сведений.

- Как использовать [очереди служебной шины](../service-bus-messaging/service-bus-dotnet-get-started-with-queues.md)
- Как использовать [разделы служебной шины](../service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions.md)
- Как использовать [ретрансляторы служебной шины](../service-bus-relay/service-bus-dotnet-how-to-use-relay.md)
- [Служебная шина: примеры](service-bus-samples.md)

[1]: ./media/service-bus-fundamentals-hybrid-solutions/SvcBus_01_architecture.png
[2]: ./media/service-bus-fundamentals-hybrid-solutions/SvcBus_02_queues.png
[3]: ./media/service-bus-fundamentals-hybrid-solutions/SvcBus_03_topicsandsubscriptions.png
[4]: ./media/service-bus-fundamentals-hybrid-solutions/SvcBus_04_relay.png

<!---HONumber=AcomDC_0928_2016-->