<properties 
	pageTitle="Работа с серверной мобильной службой JavaScript" 
	description="Содержит примеры того, как определить, зарегистрировать и использовать серверные сценарии в мобильных службах Azure." 
	services="mobile-services" 
	documentationCenter="" 
	authors="RickSaling" 
	manager="dwrede" 
	editor=""/>

<tags 
	ms.service="mobile-services" 
	ms.workload="mobile" 
	ms.tgt_pltfrm="javascript" 
	ms.devlang="multiple" 
	ms.topic="article" 
	ms.date="07/21/2016" 
	ms.author="ricksal"/>


# Работа с серверной мобильной службой JavaScript

Эта статья содержит подробную информацию о программировании серверной части на JavaScript в мобильных службах Azure и соответствующие примеры.

##<a name="intro"></a>Введение

В серверной мобильной службе JavaScript можно определить настраиваемую бизнес-логику в коде JavaScript, который хранится и выполняется на сервере. Этот серверный код сценария назначается одной из следующих функций сервера:

+ [Операции вставки, чтения, обновления или удаления данной таблицы][Table operations].
+ [Запланированные задания][Job Scheduler].
+ [HTTP-методы, определенные в настраиваемом API-интерфейсе][Custom API anchor].

Подпись основной функции в серверном скрипте зависит от контекста использования скрипта. Можно также определить общий код скрипта как модули nodes.js, которые являются общими для скриптов. Дополнительные сведения содержатся в разделе [Система управления версиями и общий код][Source control, shared code, and helper functions]

Описания отдельных объектов и функций серверных скриптов см. в разделе [Справочник серверных скриптов мобильных служб]


##<a name="table-scripts"></a>Операции с таблицами

Сценарий операций с таблицами — это серверный сценарий, который зарегистрирован для операций вставки, чтения, обновления или удаления таблицы (*del*). В этом разделе описывается работа с операциями таблицы в серверном приложении JavaScript. Доступны следующие подразделы.

+ [Обзор операций с таблицами][Basic table operations]
+ [Практическое руководство. Регистрация для операций с таблицами]
+ [Практическое руководство. Переопределение отклика по умолчанию]
+ [Практическое руководство. Переопределение успешного выполнения]
+ [Практическое руководство. Переопределение обработки ошибок по умолчанию]
+ [Практическое руководство. Создание уникальных значений идентификатора](#generate-guids)
+ [Практическое руководство. Добавление пользовательских параметров]
+ [Практическое руководство. Работа с пользователями таблицы][How to: Work with users]

###<a name="basic-table-ops"></a>Обзор операций с таблицами

Имя скрипта должно совпадать с типом операции, для которой он зарегистрирован. Для данной операции с таблицей может быть зарегистрирован только один скрипт. Скрипт выполняется каждый раз при вызове данной операции запросом REST, например при получении запроса POST для вставки элемента в таблицу. Мобильные службы не сохраняют состояния между выполнениями скриптов. Так как каждый раз, когда запускается скрипт, создается новый глобальный контекст, снова инициализируются все состояния переменных, определенных в скрипте. Если требуется сохранять состояние от одного запроса к другому, создайте в своей мобильной службе таблицу, а затем читайте и записывайте состояние в таблицу. Дополнительные сведения см. в разделе [Практическое руководство. Доступ к таблицам из скриптов].

Скрипты операций с таблицами пишутся при необходимости применять настраиваемую бизнес-логику при выполнении операции. Например, в приведенном ниже скрипте отклоняются операции вставки, если в строке поля `text` больше десяти символов.

	function insert(item, user, request) {
	    if (item.text.length > 10) {
	        request.respond(statusCodes.BAD_REQUEST, 
				'Text length must be less than 10 characters');
	    } else {
	        request.execute();
	    }
	}

Функция скрипта таблицы всегда принимает три аргумента.

- Первый аргумент зависит от операции с таблицей.

	- Для вставок и обновлений — это объект **item**, который является JSON-представлением строки, затронутой операцией. Это позволяет получить доступ к значениям столбцов по имени, например, *элемент.Владелец*, где *Владелец* является одним из имен в JSON-представлении.
	- Для удаления это идентификатор записи, которую требуется удалить.
	- Наконец, для чтения это [объект query], задающий набор строк для возврата.

- Второй аргумент — всегда [объект user][User object], который представляет пользователя, отправившего запрос.

- Третьим аргументом всегда является [объект request][request object], позволяющий контролировать выполнение запрошенной операции и ответ, который отправляется клиенту.

Ниже приведены канонические подписи функций main для операций с таблицей.

+ [Функция Insert][insert function]\: `function insert (item, user, request) { ... }`
+ [Функция Update][update function]\: `function update (item, user, request) { ... }`
+ [Функция Delete][delete function]\: `function del (id, user, request) { ... }`
+ [Функция Read][read function]\: `function read (query, user, request) { ... }`

>[AZURE.NOTE]Так как delete является зарезервированным ключевым словом в JavaScript, функция, зарегистрированная для операции удаления, должна включать имя _del_.

Каждый серверный скрипт имеет функцию main и может иметь дополнительные вспомогательные функции. Даже если серверный скрипт был создан для определенной таблицы, он может также ссылаться на другие таблицы в той же базе данных. Можно также определить общие функции как модули, которые могут быть общими для скриптов. Дополнительные сведения содержатся в разделе [Система управления версиями и общий код][Source control, shared code, and helper functions]

###<a name="register-table-scripts"></a>Практическое руководство. Регистрация скриптов таблицы

Серверные скрипты, которые зарегистрированы для операции с таблицей, можно определить одним из следующих способов:

+ Перейдите на [классический портал Azure]. Доступ к скриптам для операций с таблицами осуществляется во вкладке **Скрипты** для данной таблицы. Ниже показан код по умолчанию, зарегистрированный для скрипта вставки для таблицы `TodoItem`. Можно переопределить этот код с помощью собственной настраиваемой бизнес-логики.

	![1][1]
	
	Чтобы узнать, как это сделать, см. раздел [Проверка и изменение данных в мобильных службах с помощью серверных скриптов].

+ С помощью системы управления версиями. При включенной системе управления версиями просто создайте файл с именем <em>`<table>`</em>.<em>`<operation>`</em>.js во вложенной папке .\\service\\table репозитория git, где <em>`<table>`</em> — имя таблицы, а <em>`<operation>`</em> — операция с таблицей, которая регистрируется. Дополнительные сведения содержатся в разделе [Система управления версиями и общий код][Source control, shared code, and helper functions]

+ В командной строке с помощью программы командной строки Azure. Дополнительные сведения см. в разделе [Использование программы командной строки].


Скрипт операции с таблицей должен вызывать по крайней мере одну из перечисленных ниже функций [объекта запроса], чтобы гарантировать получение ответа клиентом.
 
+ **Функция execute**: операция завершается в соответствии с запросом и возвращается стандартный ответ.
 
+ **Функция respond**: возвращается настраиваемый ответ.

> [AZURE.IMPORTANT] Когда сценарий содержит путь кода, в котором не вызывается ни функция **execute**, ни функция **respond**, операция может перестать отвечать.

Следующий скрипт вызывает функцию **execute** для завершения операции с данными, запрошенной клиентом:

	function insert(item, user, request) { 
	    request.execute(); 
	}

В этом примере элемент вставляется в базу данных, а пользователю возвращается код соответствующего состояния.

При выполнения операции используется первый аргумент функции **execute** — `item`, объект [query][query object] или значение `id`, переданное в качестве первого аргумента в функцию скрипта. Для операции вставки, обновления или запроса можно изменить значение item или query перед вызовом функции **execute**.

	function insert(item, user, request) { 
	    item.scriptComment =
			'this was added by a script and will be saved to the database'; 
	    request.execute(); 
	} 
 
	function update(item, user, request) { 
	    item.scriptComment = 
			'this was added by a script and will be saved to the database'; 
	    request.execute(); 
	} 

	function read(query, user, request) { 
		// Only return records for the current user 	    
		query.where({ userid: user.userId}); 
	    request.execute(); 
	}
 
>[AZURE.NOTE]В скрипте удаления изменение значения предоставляемой переменной userId не влияет на то, какая запись удаляется.

Дополнительные примеры см. в разделах [Чтение и запись данных], [Изменение запроса] и [Проверка данных].


###<a name="override-response"></a>Практическое руководство. Переопределение отклика по умолчанию

Скрипт также можно использовать для реализации логики проверки, чтобы переопределить отклик по умолчанию. Если проверка не пройдена, просто вызовите функцию **respond** вместо функции **execute** и запишите ответ клиенту.

	function insert(item, user, request) {
	    if (item.userId !== user.userId) {
	        request.respond(statusCodes.FORBIDDEN, 
	        'You may only insert records with your userId.');
	    } else {
	        request.execute();
	    }
	}

В этом примере запрос отклоняется, если свойство `userId` вставляемого элемента не соответствует свойству `userId` [объекта USER], который предоставляется для клиента, прошедшего проверку подлинности. В данном случае операции с базой данных (*insert*) не производится и клиенту возвращается ответ с настраиваемым сообщением об ошибке и кодом состояния HTTP 403. Дополнительные примеры см. в разделе [Изменение отклика].

###<a name="override-success"></a>Практическое руководство. Переопределение успешного выполнения

По умолчанию в операции с таблицей функция **execute** автоматически записывает ответы. Тем не менее в функцию "execute" можно передать два необязательных параметра, которые переопределят ее поведение в случае успеха или ошибки.

Передавая обработчик **success** при вызове функции "execute", можно изменить результаты запроса до их записи в ответ. В следующем примере вызывается функция `execute({ success: function(results) { ... })`. Она выполняет дополнительные действия после чтения данных из базы данных, но перед записью отклика.

	function read(query, user, request) {
	    request.execute({
	        success: function(results) {
	            results.forEach(function(r) {
	                r.scriptComment = 
	                'this was added by a script after querying the database';
	            });
	            request.respond();
	        }
	    });
	}

При вводе обработчика **success** для функции **execute** необходимо также вызвать функцию **respond** как часть обработчика **success**, чтобы среда выполнения знала, что скрипт завершен и можно записать ответ. При вызове функции **respond** без передачи каких-либо аргументов, мобильные службы создают ответ по умолчанию.

>[AZURE.NOTE]Функцию **respond** без аргументов для вызова ответа по умолчанию можно вызвать, только после вызова функции **execute**.
 
###<a name="override-error"></a>Практическое руководство. Переопределение обработки ошибок по умолчанию

Функция **execute** может завершиться ошибкой в случае потери подключения к базе данных, недопустимого объекта или неверного запроса. По умолчанию при возникновении ошибки серверные скрипты записывают ошибку в журнал и записывают ошибочный результат в ответ. Поскольку мобильные службы обеспечивают обработку ошибок по умолчанию, нет необходимости обрабатывать ошибки, возникающие в службе.

Если вы хотите произвести определенное компенсирующее действие или использовать глобальный консольный объект для записи в журнал более подробных сведений, то обработку ошибок по умолчанию можно переопределить путем реализации явной обработки ошибок. Это можно сделать, указав обработчик **error** для функции **execute**:

	function update(item, user, request) { 
	  request.execute({ 
	    error: function(err) { 
	      // Do some custom logging, then call respond. 
	      request.respond(); 
	    } 
	  }); 
	}
 

Если имеется обработчик ошибок, мобильные службы возвращают клиенту результат ошибки при вызове функции **respond**.

При желании можно указать и обработчик **success**, и обработчик **error**.

###<a name="generate-guids"></a>Практическое руководство. Создание уникальных значений идентификатора

Мобильные службы поддерживают уникальные настраиваемые строковые значения для столбца **id** таблицы. Это позволяет приложениям использовать в качестве идентификатора настраиваемые значения, такие как адреса электронной почты или имена пользователей.

Строковые идентификаторы предоставляют следующие преимущества.

+ Идентификаторы создаются без обмена данными с базой данных.
+ Можно легко объединять записи из разных таблиц или баз данных.
+ Значения идентификаторов можно удобно интегрировать с логикой приложения.

Если не задано строковое значение идентификатора для вставленной записи, мобильные службы создают уникальное значение для идентификатора. Можно создавать собственные уникальные значения идентификатора в серверных скриптах. В следующем примере скрипта создается настраиваемый идентификатор GUID, который назначается идентификатору новой записи. Этот идентификатор похож на значение, создаваемое мобильными службами, если не передать значение идентификатора записи.

	// Example of generating an id. This is not required since Mobile Services
	// will generate an id if one is not passed in.
	item.id = item.id || newGuid();
	request.execute();

	function newGuid() {
		var pad4 = function(str) { return "0000".substring(str.length) + str; };
		var hex4 = function () { return pad4(Math.floor(Math.random() * 0x10000 /* 65536 */ ).toString(16)); };
		return (hex4() + hex4() + "-" + hex4() + "-" + hex4() + "-" + hex4() + "-" + hex4() + hex4() + hex4());
	}


Если приложение предоставляет значение для идентификатора, мобильные службы сохраняют его как есть. (В том числе с начальными или конечными пробелами.) Пробелы не удаляются из значения.

Значение для `id` должно быть уникальным и не должно содержать символы из следующих наборов:

+ Управляющие символы: [0x0000-0x001F] и [0x007F-0x009F]. Дополнительные сведения см. в статье [Управляющие коды ASCII C0 и C1](http://en.wikipedia.org/wiki/Data_link_escape_character#C1_set).
+  Печатные символы: **"**(0x0022), **+** (0x002B), **/** (0x002F), **?** (0x003F), **\** (0x005C), **`** (0x0060)
+  Идентификаторы "." и ".."

Также для таблиц можно использовать целочисленные идентификаторы. Для этого необходимо создать таблицу с помощью команды `mobile table create`, используя параметр `--integerId`. Эта команда используется в интерфейсе командной строки (CLI) Azure. Дополнительные сведения об использовании CLI см. в статье [Интерфейс командной строки для управления таблицами мобильных служб](../virtual-machines-command-line-tools.md#Mobile_Tables).


###<a name="access-headers"></a>Практическое руководство. Доступ к настраиваемым параметрам

При отправке запроса к мобильной службе можно включить настраиваемые параметры в URI запроса, чтобы указать скриптам операций с таблицей, как обращаться с данным запросом. Измените скрипт для проверки параметра, чтобы определить путь обработки.

Например, следующий URI для запроса POST сообщает службе не допускать вставки нового элемента *TodoItem*, который имеет то же текстовое значение:

		https://todolist.azure-mobile.net/tables/TodoItem?duplicateText=false

Доступ к этим настраиваемым параметрам запроса осуществляется как к JSON-значениям из свойства **параметры** [объекта запроса]. Мобильные службы предоставляют объект **запрос** для любой функции, зарегистрированной для операции с таблицей. Следующий серверный скрипт для операции вставки проверяет значение параметра `duplicateText` перед операцией вставки.

		function insert(item, user, request) {
		    var todoItemTable = tables.getTable('TodoItem');
		    // Check the supplied custom parameter to see if
		    // we should allow duplicate text items to be inserted.		   
		    if (request.parameters.duplicateText === 'false') {
		        // Find all existing items with the same text
		        // and that are not marked 'complete'. 
		        todoItemTable.where({
		            text: item.text,
		            complete: false
		        }).read({
		            success: insertItemIfNotComplete
		        });
		    } else {
		        request.execute();
		    }

		    function insertItemIfNotComplete(existingItems) {
		        if (existingItems.length > 0) {
		            request.respond(statusCodes.CONFLICT, 
                        "Duplicate items are not allowed.");
		        } else {
		            // Insert the item as normal. 
		            request.execute();
		        }
		    }
		}

Обратите внимание, что в **insertItemIfNotComplete** функция **execute** [объекта запроса] вызывается для вставки элемента при отсутствии повторяющегося текста; в противном случае вызывается функция **respond**, которая уведомляет клиента о повторе.

Обратите внимание на синтаксис вызова функции **success** в приведенном выше коде.

 		        }).read({
		            success: insertItemIfNotComplete
		        });

В JavaScript это компактная версия более длинного эквивалента:

		success: function(results) 
		{ 
			insertItemIfNotComplete(results); 
		}


###<a name="work-with-users"></a>Практическое руководство. Работа с пользователями

В мобильных службах Azure можно использовать поставщика удостоверений для проверки подлинности пользователей. Дополнительные сведения см. в разделе [Приступая к работе с аутентификацией]. Когда прошедший проверку пользователь вызывает операцию с таблицей, мобильные службы используют [объект пользователя] для предоставления сведений о пользователе зарегистрированной функции скрипта. Свойство **userId** можно использовать для хранения и извлечения данных конкретного пользователя. В следующем примере устанавливается свойство владельца элемента на основе ИД пользователя, прошедшего проверку (**userId**):

	function insert(item, user, request) {
	    item.owner = user.userId;
	    request.execute();
	}

В следующем примере добавляется дополнительный фильтр запроса на основе **userId** прошедшего проверку пользователя. Этот фильтр ограничивает результаты только теми элементами, которые принадлежат текущему пользователю:

	function read(query, user, request) {
	    query.where({
	        owner: user.userId
	    });
	    request.execute();
	}

##<a name="custom-api"></a>Настраиваемые интерфейсы API

В этом разделе описывается, как создавать настраиваемые конечные точки API и работать с ними (ниже перечислены соответствующие подразделы).
	
+ [Общие сведения о настраиваемых интерфейсах API](#custom-api-overview)
+ [Практическое руководство. Определение настраиваемого интерфейса API]
+ [Практическое руководство. Реализация методов HTTP]
+ [Практическое руководство. Отправка и получение данных в формате XML]
+ [Практическое руководство. Работа с пользователями и заголовками в настраиваемом интерфейсе API]
+ [Практическое руководство. Определение нескольких маршрутов настраиваемого интерфейса API]

###<a name="custom-api-overview"></a>Общие сведения о настраиваемых интерфейсах API

Настраиваемый интерфейс API является конечной точкой в вашей мобильной службе, доступ к которой осуществляется с помощью одного или нескольких стандартных методов HTTP: GET, POST, PUT, PATCH, DELETE. Для каждого метода HTTP, который поддерживает настраиваемый интерфейс API, можно определить отдельную функцию экспорта в одном и том же файле скрипта. Зарегистрированный скрипт вызывается при получении запроса настраиваемого интерфейса API с помощью данного метода. Дополнительные сведения см. в разделе [Настраиваемый интерфейс API].

При вызове функций настраиваемого интерфейса API средой выполнения мобильных служб поставляются и объект [запроса][request object], и объект [ответа][response object]. Эти объекты предоставляют функциональные возможности [библиотеки express.js], которыми можно управлять с помощью скриптов. Приведенный ниже настраиваемый API-интерфейс с именем **hello** — это очень простой пример, который возвращает фразу _Hello, world!_ в ответ на запрос POST.

		exports.post = function(request, response) {
		    response.send(200, "{ message: 'Hello, world!' }");
		} 

Функция **send** [объекта ответа] возвращает нужный ответ клиенту. Этот код вызывается отправлением запроса POST по следующему URL-адресу:

		https://todolist.azure-mobile.net/api/hello  

Глобальное состояние сохраняется между выполнениями.

###<a name="define-custom-api"></a>Практическое руководство. Определение настраиваемого интерфейса API

Серверные скрипты, которые зарегистрированы для методов HTTP в конечной точке настраиваемого интерфейса API, можно определить одним из следующих способов:

+ Перейдите на [классический портал Azure]. Скрипты настраиваемого интерфейса API создаются и изменяются во вкладке **API**. Код серверного скрипта находится во вкладке **Скрипты** данного настраиваемого интерфейса API. Ниже приведен скрипт, который вызывается по запросу POST к конечной точке `CompleteAll` настраиваемого интерфейса API.

	![2][2]
	
	На вкладке "Разрешения" назначаются разрешения на доступ для методов настраиваемого интерфейса API. Как был создан этот настраиваемый интерфейс API, см. в разделе [Вызов настраиваемого API из клиента]

+ С помощью системы управления версиями. При включенной системе управления версиями просто создайте файл с именем <em>`<custom_api>`</em>.js во вложенной папке .\\service\\api репозитория git, где <em>`<custom_api>`</em> — имя настраиваемого интерфейса API, который регистрируется. Этот файл скрипта содержит функцию _exported_ для каждого метода HTTP, предоставляемого настраиваемым API-интерфейсом. Разрешения определены в файле-компаньоне .json. Дополнительные сведения содержатся в разделе [Система управления версиями и общий код][Source control, shared code, and helper functions]

+ В командной строке с помощью программы командной строки Azure. Дополнительные сведения см. в разделе [Использование программы командной строки].

###<a name="handle-methods"></a>Практическое руководство. Реализация методов HTTP

Настраиваемый интерфейс API может обрабатывать один или несколько методов HTTP: GET, POST, PUT, PATCH и DELETE. Для каждого HTTP-метода, который обрабатывает настраиваемый интерфейс API, определяется экспортированная функция. Один файл кода настраиваемого API может экспортировать одну или все из следующих функций:

		exports.get = function(request, response) { ... };
		exports.post = function(request, response) { ... };
		exports.patch = function(request, response) { ... };
		exports.put = function(request, response) { ... };
		exports.delete = function(request, response) { ... };

Конечную точку настраиваемого интерфейса API нельзя вызвать с помощью HTTP-метода, который не был реализован в серверном скрипте, и возвращается сообщение об ошибке 405 (недопустимый метод). Для каждого HTTP-метода поддержки можно назначить отдельные уровни разрешения.

###<a name="api-return-xml"></a>Практическое руководство. Отправка и получение данных в формате XML

Когда клиенты хранят и извлекают данные, мобильные службы используют JavaScript Object Notation (JSON) для представления данных в теле сообщения. Однако существуют скрипты, где вместо этого требуется использовать полезные данные формата XML. Например, приложения для магазина Windows имеют встроенные возможности периодических уведомлений, для которых требуется, чтобы служба выдавала XML. Дополнительные сведения содержатся в разделе [Определение настраиваемого интерфейса API с поддержкой периодических уведомлений].

Следующая функция настраиваемого API-интерфейса **OrderPizza** возвращает простой XML-документ как полезные данные ответа:

		exports.get = function(request, response) {
		  response.set('content-type', 'application/xml');
		  var xml = '<?xml version="1.0"?><PizzaOrderForm><PizzaOrderForm/>';
		  response.send(200, xml);
		};

Эта функция настраиваемого API вызывается с помощью запроса HTTP GET к следующей конечной точке:

		https://todolist.azure-mobile.net/api/orderpizza

###<a name="get-api-user"></a>Практическое руководство. Работа с пользователями и заголовками в настраиваемом интерфейсе API

В мобильных службах Azure можно использовать поставщика удостоверений для проверки подлинности пользователей. Дополнительные сведения см. в разделе [Приступая к работе с аутентификацией]. Когда пользователь с подтвержденной подлинностью запрашивает настраиваемый интерфейс API, мобильные службы используют [объект пользователя], чтобы предоставить сведения о пользователе для кода настраиваемого API. Доступ к [объекту пользователя] осуществляется через свойство пользователя [объекта запроса]. Свойство **userId** можно использовать для хранения и извлечения данных конкретного пользователя.

Следующая функция настраиваемого API-интерфейса **OrderPizza** задает свойство владельца элемента на основе ИД пользователя (**userId**), прошедшего проверку подлинности:

		exports.post = function(request, response) {
			var userTable = request.service.tables.getTable('user');
			userTable.lookup(request.user.userId, {
				success: function(userRecord) {
					callPizzaAPI(userRecord, request.body, function(orderResult) {
						response.send(201, orderResult);
					});
				}
			});
		
		};

Эта функция настраиваемого API вызывается с помощью запроса HTTP POST к следующей конечной точке:

		https://<service>.azure-mobile.net/api/orderpizza

Доступ к конкретному заголовку HTTP можно также получить из [объекта запроса], как показано в следующем коде:

		exports.get = function(request, response) {    
    		var header = request.header('my-custom-header');
    		response.send(200, "You sent: " + header);
		};

Этот простой пример считывает настраиваемый заголовок с именем `my-custom-header`, а затем возвращает значение в ответе.

###<a name="api-routes"></a>Практическое руководство. Определение нескольких маршрутов настраиваемого интерфейса API

Мобильные службы позволяют определить несколько путей или маршрутов в настраиваемом интерфейсе API. Например, HTTP-запрос GET на следующий URL-адрес в настраиваемом интерфейсе API **калькулятор** будет вызывать функцию **add** или **subtract** соответственно:

+ `https://<service>.azure-mobile.net/api/calculator/add`
+ `https://<service>.azure-mobile.net/api/calculator/sub`

Несколько маршрутов определяются путем экспорта функции **register**, которая передает объект **api** (подобно [объекту express в express.js]), используемый для регистрации маршрутов в конечной точке настраиваемого API. В следующем примере реализуются методы **add** и **sub** в настраиваемом интерфейсе API **калькулятор**:

		exports.register = function (api) {
		    api.get('add', add);
		    api.get('sub', subtract);
		}
		
		function add(req, res) {
		    var result = parseInt(req.query.a) + parseInt(req.query.b);
		    res.send(200, { result: result });
		}
		
		function subtract(req, res) {
		    var result = parseInt(req.query.a) - parseInt(req.query.b);
		    res.send(200, { result: result });
		}

Объект **api**, переданный функции **register**, предоставляет функцию для каждого метода HTTP (**get**, **post**, **put**, **patch**, **delete**). Эти функции регистрируют маршрут к определенной функции для конкретного метода HTTP. Каждая функция принимает два параметра: первый — имя маршрута, а второй — функция, зарегистрированная для маршрута.

Два маршрута в приведенном выше примере настраиваемого API могут вызываться HTTP-запросами GET (показаны с ответом) следующим образом:

+ `https://<service>.azure-mobile.net/api/calculator/add?a=1&b=2`

		{"result":3}

+ `https://<service>.azure-mobile.net/api/calculator/sub?a=3&b=5`

		{"result":-2}

##<a name="scheduler-scripts"></a>Планировщик заданий

Мобильные службы позволяют определить серверные скрипты, которые выполняются либо как задания по фиксированному расписанию, либо по требованию с классического портала Azure. Запланированные задания можно использовать для выполнения периодических задач, таких как очистка данных таблицы и пакетная обработка. Дополнительные сведения см. в разделе [Расписание заданий].

Скрипты, зарегистрированные для запланированных заданий, имеют функцию "main" с тем же именем, что и запланированное задание. Поскольку запланированный скрипт не вызывается с помощью запроса HTTP, не существует контекста, который может быть передан средой выполнения сервера, и функция не принимает параметров. Как и для других видов скриптов, у вас могут быть функции подпрограмм и требование общих модулей. Дополнительные сведения содержатся в разделе [Система управления версиями, общий код и вспомогательные функции].

###<a name="scheduler-scripts"></a>Практическое руководство. Определение скриптов запланированных заданий

Серверные скрипты могут назначаться заданию, определенному в планировщике мобильных служб. Эти скрипты относятся к заданию и выполняются согласно расписания заданий. (Можно также использовать [классический портал Azure] для выполнения заданий по запросу.) Скрипт, определяющий запланированное задание, не имеет параметров, так как мобильные службы не передают ему никаких данных; он выполняется как регулярная функция JavaScript и непосредственно не взаимодействует с мобильными службами.

Запланированные задания определяются одним из следующих способов:

+ На [классическом портале Azure] на вкладке **Сценарий** в планировщике:

	![3][3]

	Дополнительные сведения о том, как это сделать, см. в разделе [Планирование заданий сервера в мобильных службах].

+ В командной строке с помощью программы командной строки Azure. Дополнительные сведения см. в разделе [Использование программы командной строки].

>[AZURE.NOTE]Если система управления версиями включена, можно редактировать файлы скриптов запланированных заданий непосредственно во вложенной папке .\\service\\scheduler в репозитории git. Дополнительные сведения содержатся в разделе [Практическое руководство. Совместное использование кода с помощью системы управления версиями].

##<a name="shared-code"></a>Система управления версиями, общий код и вспомогательные функции

В следующих разделах показано, как использовать систему управления версиями для добавления собственных настраиваемых модулей node.js, общего кода и других стратегий повторного использования кода (разделы перечислены ниже).

+ [Обзор использования общего кода](#leverage-source-control)
+ [Практическое руководство. Загрузка модулей Node.js]
+ [Практическое руководство. Использование вспомогательных функций]
+ [Практическое руководство. Совместное использование кода с помощью системы управления версиями]
+ [Практическое руководство. Работа с параметрами приложения]

###<a name="leverage-source-control"></a>Обзор использования общего кода

Так как Node.js используется мобильными службами на сервере, скрипты уже имеют доступ к встроенным модулям Node.js. Также можно использовать систему управления версиями для определения собственных модулей или добавления других модулей Node.js к службе.

Ниже представлены лишь некоторые полезные модули, которые могут использоваться в скрипте с помощью глобальной функции **require**:

+ **azure**: предоставляет функциональные возможности пакета SDK для Azure для Node.js. Дополнительную информацию см. в разделе [Azure SDK for Node.js] \(Пакет SDK для Azure для Node.js).
+ **crypto**: обеспечивает функциональные возможности шифрования OpenSSL. Дополнительные сведения см. в [Документации по Node.js][crypto API].
+ **path**: содержит служебные программы для работы с путями к файлам. Дополнительные сведения см. в [Документации по Node.js][path API].
+ **querystring**: содержит служебные программы для работы со строками запросов. Дополнительные сведения см. в [Документации по Node.js][querystring API].
+ **request**: отправляет HTTP-запросы к внешним службам REST, таким как Twitter и Facebook. Дополнительные сведения см. в разделе [Отправка запроса HTTP].
+ **sendgrid**: отправляет электронную почту с помощью службы электронной почты Sendgrid в Azure. Дополнительные сведения содержатся в разделе [Отправка электронной почты с мобильных служб с помощью SendGrid].
+ **url**: содержит служебные программы для анализа и разрешения URL-адресов. Дополнительные сведения см. в [Документации по Node.js][url API].
+ **util**: содержит различные вспомогательные программы, такие как форматирование строки и проверка типа объекта. Дополнительные сведения см. в [Документации по Node.js][util API].
+ **zlib**: предоставляет функциональные возможности сжатия, например gzip и deflate. Дополнительные сведения см. в [Документации по Node.js][zlib API].

###<a name="modules-helper-functions"></a>Практическое руководство. Использование модулей

Мобильные службы предоставляют набор модулей, загружаемых скриптами с помощью глобальной функции **require**. Например, скрипт может требовать функцию **request** для выполнения HTTP-запросов:

	function update(item, user, request) { 
	    var httpRequest = require('request'); 
	    httpRequest('http://www.google.com', function(err, response, body) { 
	    	... 
	    }); 
	} 


###<a name="shared-code-source-control"></a>Практическое руководство. Совместное использование кода с помощью системы управления версиями

Система управления версиями с диспетчером пакетов Node.js (npm) позволяет контролировать, какие модули доступны для вашей мобильной службы. Это можно осуществить двумя путями:

+ Для модулей, опубликованных и установленных с помощью npm, объявите пакеты, которые должна устанавливать мобильная служба, в файле package.json. Таким образом служба всегда имеет доступ к последней версии необходимых пакетов. Файл package.json находится в каталоге `.\service`. Дополнительные сведения содержатся в разделе [Поддержка package.json в мобильных службах Azure].

+ Для закрытых или настраиваемых модулей можно использовать npm, чтобы вручную установить модуль в каталог `.\service\node_modules` системы управления версиями. Пример того, как вручную загрузить модуль, см. в разделе [Использование общего кода и модулей Node.js в серверных скриптах].

	>[AZURE.NOTE]Если `node_modules` уже существует в иерархии каталогов, диспетчер пакетов NPM создает там подкаталог `\node-uuid`, а не каталог `node_modules` в репозитории. В этом случае просто удалите существующий каталог `node_modules`.

После применения файла package.json или настраиваемых модулей к репозиторию для мобильной службы, используйте функцию **require** для ссылки на модули по имени.

>[AZURE.NOTE] Модули, которые вы указали в package.json или загрузили в свою мобильную службу, используются только в коде серверного скрипта. Эти модули не используются средой выполнения мобильных служб.

###<a name="helper-functions"></a>Практическое руководство. Использование вспомогательных функций

Помимо запрашивания модулей, отдельные серверные скрипты могут включать вспомогательные функции. Это функции, не зависимые от основной функции, которые можно использовать для разделения кода в скрипте.

В следующем примере регистрируется скрипт таблицы для операции вставки, которая включает вспомогательную функцию **handleUnapprovedItem**:


	function insert(item, user, request) {
	    if (!item.approved) {
	        handleUnapprovedItem(item, user, request);
	    } else {
	        request.execute();
	    }
	}
	
	function handleUnapprovedItem(item, user, request) {
	    // Do something with the supplied item, user, or request objects.
	}
 
В скрипте вспомогательные функции должны быть объявлены после основной функции. В скрипте необходимо объявить все переменные. Необъявленные переменные приводят к ошибке.

Определенные один раз вспомогательные функции также могут совместно использоваться серверными скриптами. Чтобы функция могла совместно использоваться сценариями, функции необходимо экспортировать, а в каталоге `.\service\shared` должен существовать файл скрипта. Ниже приведен шаблон для экспорта общей функции в файл `.\services\shared\helpers.js`.

		exports.handleUnapprovedItem = function (tables, user, callback) {
		    
		    // Do something with the supplied tables or user objects and 
			// return a value to the callback function.
		};
 
Затем такую функцию можно использовать в скрипте операции с таблицей.

		function insert(item, user, request) {
		    var helper = require('../shared/helper');
		    helper.handleUnapprovedItem(tables, user, function(result) {
		        	
					// Do something based on the result.
		            request.execute();
		        }
		    }
		}

В этом примере необходимо передать общей функции [объект таблицы] и [объект пользователя]. Это связано с тем, что для общих скриптов недоступен глобальный [объект таблицы], а [объект пользователя] существует только в контексте запроса.

Файлы скриптов передаются в общий каталог с помощью [системы управления версиями][How to: Share code by using source control] или с помощью [средства командной строки][Using the command line tool].

###<a name="app-settings"></a>Практическое руководство. Работа с параметрами приложения

Мобильные службы позволяют безопасно хранить значения как параметры приложения, к которым могут получить доступ серверные скрипты в среде выполнения. При добавлении данных к параметрам приложения мобильных служб пары "имя/значение" сохраняются в зашифрованном виде и доступны в серверных скриптах без размещения их в файле скрипта. Дополнительные сведения см. в разделе [Параметры приложения].

В следующем примере настраиваемый интерфейс API использует предоставленный [объект службы] для извлечения значения параметра приложения.

		exports.get = function(request, response) {
		
			// Get the MY_CUSTOM_SETTING value from app settings.
		    var customSetting = 
		        request.service.config.appSettings.my_custom_setting;
				
			// Do something and then send a response.

		}

Следующий код использует модуль настройки для получения значения маркера доступа к Twitter, который хранится в параметрах приложения, используемых в скрипте запланированных заданий:

		// Get the service configuration module.
		var config = require('mobileservice-config');

		// Get the stored Twitter consumer key and secret. 
		var consumerKey = config.twitterConsumerKey,
		    consumerSecret = config.twitterConsumerSecret
		// Get the Twitter access token from app settings.    
		var accessToken= config.appSettings.TWITTER_ACCESS_TOKEN,
		    accessTokenSecret = config.appSettings.TWITTER_ACCESS_TOKEN_SECRET;

Обратите внимание, что этот код также извлекает значения ключа потребителя Twitter, хранящиеся во вкладке **Удостоверение** на портале. Поскольку функция **config object** недоступна в скриптах операции с таблицами и запланированных заданий, для доступа к параметрам приложения необходимо использовать модуль конфигурации. Полный пример см. в разделе [Планирование серверных заданий в мобильных службах].

<h2><a name="command-prompt"></a>Использование программы командной строки</h2>

В мобильных службах можно создавать, изменять и удалять серверные скрипты с помощью средства командной строки Azure. Перед отправкой скриптов убедитесь, что используется следующая структура каталогов:

![4\.][4]

Обратите внимание, что эта структура каталогов такая же, как и репозиторий git при использовании системы управления версиями.

При отправке файлов скрипта из программы командной строки необходимо сначала перейти в каталог `.\services`. Следующая команда отправляет скрипт с именем `todoitem.insert.js` из подкаталога `table`:

		~$azure mobile script upload todolist table/todoitem.insert.js
		info:    Executing command mobile script upload
		info:    mobile script upload command OK

Следующая команда возвращает сведения о каждом файле скрипта, размещенном в вашей мобильной службе:

		~$ azure mobile script list todolist
		info:    Executing command mobile script list
		+ Retrieving script information
		info:    Table scripts
		data:    Name                       Size
		data:    -------------------------  ----
		data:    table/channels.insert      1980
		data:    table/TodoItem.insert      5504
		data:    table/TodoItem.read        64
		info:    Shared scripts
		data:    Name              Size
		data:    ----------------  ----
		data:    shared/helper.js  62
		data:    shared/uuid.js    7452
		info:    Scheduled job scripts
		data:    Job name    Script name           Status    Interval     Last run  Next run
		data:    ----------  --------------------  --------  -----------  --------  --------
		data:    getUpdates  scheduler/getUpdates  disabled  15 [minute]  N/A       N/A
		info:    Custom API scripts
		data:    Name                    Get          Put          Post         Patch        Delete
		data:    ----------------------  -----------  -----------  -----------  -----------  -----------
		data:    completeall             application  application  application  application  application
		data:    register_notifications  application  application  user         application  application
		info:    mobile script list command OK

Дополнительные сведения см. в разделе [Команды для управления мобильными службами Azure].

##<a name="working-with-tables"></a>Работа с таблицами

В этом разделе описаны стратегии для работы непосредственно с данными таблицы базы данных SQL (подразделы перечислены ниже).

+ [Общие сведения о работе с таблицами](#overview-tables)
+ [Практическое руководство. Доступ к таблицам из скриптов]
+ [Практическое руководство. Выполнение массовой вставки]
+ [Практическое руководство. Сопоставление типов JSON с типами баз данных]
+ [Использование языка Transact-SQL для доступа к таблицам]

###<a name="overview-tables"></a>Общие сведения о работе с таблицами

Для многих скриптов мобильных служб необходимы серверные скрипты для доступа к таблицам в базе данных. К примеру, поскольку мобильные службы не сохраняют состояния между выполнениями скрипта, любые данные, которые должны сохраняться между выполнениями скрипта, должны храниться в таблицах. Можно также просмотреть записи в таблице разрешений или хранения данных аудита, а не просто записать их в журнал, где данные хранятся ограниченное время и не доступны программно.

Мобильные службы имеют два способа доступа к таблицам: с помощью прокси [объект таблицы] или путем составления запросов Transact-SQL с помощью [объекта mssql]. [Объект таблицы] упрощает доступ к данным таблицы из кода серверного скрипта, но [объект mssql] поддерживает более сложные операции с данными и предоставляет наибольшую гибкость.

###<a name="access-tables"></a>Практическое руководство. Доступ к таблицам из скриптов

Наиболее простой способ доступа к таблицам из скрипта — использовать [объект таблиц]. Функция **GetTable** возвращает экземпляр [объекта таблицы], который является прокси для доступа к запрашиваемой таблице. Затем можно вызвать функции прокси для доступа к данным и их изменения.

Скрипты, зарегистрированные для операций с таблицей и запланированных заданий, могут получить доступ к [объекту таблиц] как глобальному объекту. Эта строка кода возвращает прокси для таблицы *TodoItems* из глобального [объекта таблиц]\:

		var todoItemsTable = tables.getTable('TodoItems');

Скрипты настраиваемого API могут получить доступ к [объекту tables] из свойства <strong>service</strong> предоставляемого [объекта request]. Эта строка кода получает [объект таблиц] из запроса:

		var todoItemsTable = request.service.tables.getTable('TodoItem');

> [AZURE.NOTE] Общие функции не могут получить доступ к объекту **tables** напрямую. В случае общей функции необходимо передать этот объект функции.

Имея объект [table], можно вызвать одну или несколько функций операций с таблицей: вставки, обновления, удаления или чтения. Этот пример считывает разрешения пользователей из таблицы разрешений:

	function insert(item, user, request) {
		var permissionsTable = tables.getTable('permissions');
	
		permissionsTable
			.where({ userId: user.userId, permission: 'submit order'})
			.read({ success: checkPermissions });
			
		function checkPermissions(results) {
			if(results.length > 0) {
				// Permission record was found. Continue normal execution.
				request.execute();
			} else {
				console.log('User %s attempted to submit an order without permissions.', user.userId);
				request.respond(statusCodes.FORBIDDEN, 'You do not have permission to submit orders.');
			}
		}
	}

Следующий пример записывает данные аудита в таблицу **audit**:

	function update(item, user, request) {
		request.execute({ success: insertAuditEntry });
		
		function insertAuditEntry() {
			var auditTable = tables.getTable('audit');
			var audit = {
				record: 'checkins',
				recordId: item.id,
				timestamp: new Date(),
				values: JSON.stringify(item)
			};
			auditTable.insert(audit, {
				success: function() {
					// Write to the response now that all data operations are complete
					request.respond();
				}
			});
		}
	}

Последний пример — в образце кода, который можно посмотреть здесь: [Практическое руководство. Доступ к настраиваемым параметрам][How to: Add custom parameters].

###<a name="bulk-inserts"></a>Практическое руководство. Выполнение массовой вставки

При использовании цикла **for** или **while** для непосредственной вставки в таблицу большого количества элементов (например, 1000) могут возникнуть ограничения на число подключений SQL, которые приведут к сбою некоторых вставок. Ваш запрос может не завершиться или вернуть сообщение HTTP 500 "Внутренняя ошибка сервера". Чтобы избежать этой проблемы, можно вставлять элементы партиями по 10 или около того. После вставки первой партии отправьте следующую и т. д.

С помощью следующего скрипта можно установить размер пакета записей для вставки в параллельном режиме. Рекомендуется устанавливать небольшое количество записей. Функция **insertItems** вызывает себя рекурсивно при завершении асинхронной пакетной вставки. Цикл "for" в конце вставляет одну запись за один раз и вызывает **insertComplete** в случае успеха и **errorHandler** при ошибке. Функция **insertComplete** контролирует, будет ли **insertItems** вызываться рекурсивно для следующего пакета или задание выполнено и следует выйти из скрипта.

		var todoTable = tables.getTable('TodoItem');
		var recordsToInsert = 1000;
		var batchSize = 10; 
		var totalCount = 0;
		var errorCount = 0; 
		
		function insertItems() {        
		    var batchCompletedCount = 0;  
		
		    var insertComplete = function() { 
		        batchCompletedCount++; 
		        totalCount++; 
		        if(batchCompletedCount === batchSize || totalCount === recordsToInsert) {                        
		            if(totalCount < recordsToInsert) {
		                // kick off the next batch 
		                insertItems(); 
		            } else { 
		                // or we are done, report the status of the job 
		                // to the log and don't do any more processing 
		                console.log("Insert complete. %d Records processed. There were %d errors.", totalCount, errorCount); 
		            } 
		        } 
		    }; 
		
		    var errorHandler = function(err) { 
		        errorCount++; 
		        console.warn("Ignoring insert failure as part of batch.", err); 
		        insertComplete(); 
		    };
		
		    for(var i = 0; i < batchSize; i++) { 
		        var item = { text: "This is item number: " + totalCount + i }; 
		        todoTable.insert(item, { 
		            success: insertComplete, 
		            error: errorHandler 
		        }); 
		    } 
		} 
		
		insertItems(); 


Полный пример кода и сопутствующие обсуждение можно найти в этом [блоге](http://blogs.msdn.com/b/jpsanders/archive/2013/03/20/server-script-to-insert-table-items-in-windows-azure-mobile-services.aspx) Если вы используете этот код, можно адаптировать его к конкретной ситуации и тщательно протестировать.

###<a name="JSON-types"></a>Практическое руководство. Сопоставление типов JSON с типами баз данных

Коллекции типов данных на стороне клиента и в таблице базы данных мобильных служб различаются. Иногда их легко сопоставить друг с другом, иногда — нет. Мобильные службы выполняют ряд преобразований типа в сопоставлении:

- Для типов в клиентах, реализованных на разных языках, выполняется сериализация в JSON.
- Прежде чем появиться в серверном сценарии, представление JSON преобразуется в JavaScript.
- Типы данных JavaScript при сохранении с помощью [объекта tables] преобразуются в типы базы данных SQL.

Преобразование из схемы клиента в JSON меняется в зависимости от платформы. Клиенты магазина Windows и Windows Phone используют JSON.NET. Клиент Android использует библиотеку gson. Клиент iOS использует класс NSJSONSerialization. Используется сериализация по умолчанию каждой из этих библиотек за исключением того, что объекты даты преобразуются в строки JSON, содержащие даты, закодированные с помощью ISO 8601.

При написании серверных скриптов, использующих функции [insert], [update], [read] или [delete], можно получить доступ к представлению данных в JavaScript. Мобильные службы используют функцию десериализации Node.js ([JSON.parse](http://es5.github.io/#x15.12)) для преобразования объектов JSON при передаче в объекты JavaScript. Однако мобильные службы выполняют преобразование для извлечения объектов **Дата** из строк ISO 8601.

Если вы используете [объект таблиц] или [объект mssql] или просто позволяете выполниться скриптам таблицы, десериализованные объекты JavaScript вставляются в базу данных SQL. В этом процессе свойства объекта сопоставляются с типами T-SQL:

Свойство JavaScript|Тип T-SQL
---|---
Число|Float(53)
Логический|Bit
Дата|DateTimeOffset(3)|
Строка|Nvarchar(max)
Буфер|Не поддерживается
Объект|Не поддерживается
Массив|Не поддерживается
Поток|Не поддерживается

###<a name="TSQL"></a>Использование языка Transact-SQL для доступа к таблицам

Самый простой способ получить данные таблицы из серверных скриптов — использовать прокси [объект таблицы]. Тем не менее существуют более расширенные скрипты, которые не поддерживаются [объектом таблицы], такие как запросы соединения и другие сложные запросы и вызовы хранимых процедур. В этих случаях необходимо выполнить инструкции Transact-SQL непосредственно в отношении реляционной таблицы, пользуясь [объектом mssql]. Данный объект предоставляет следующие функции:

- **query**: выполняет запрос, заданный строкой TSQL; результаты возвращаются в обратном вызове **success** объекта **options**. Запрос может содержать параметры, если присутствует параметр *params*.
- **queryRaw**: похожа на *query* за исключением того, что результирующий набор возвращается из запроса в формате "raw" (см. пример ниже).
- **open**:: используется для подключения к базе данных мобильных служб, после чего объект подключения можно использовать для вызова операций базы данных, таких как транзакции.

Эти методы предоставляют более низкий уровень контроля обработки запросов.

+ [Практическое руководство. Запуск статического запроса]
+ [Практическое руководство. Запуск динамического запроса]
+ [Практическое руководство. Объединение реляционных таблиц]
+ [Практическое руководство. Выполнение запроса, возвращающего результаты в формате *raw*]
+ [Практическое руководство. Доступ для подключения к базе данных]

####<a name="static-query"></a>Практическое руководство. Запуск статического запроса

Следующий запрос не содержит параметров и возвращает три записи из таблицы `statusupdate`. Набор строк представлен в стандартном формате JSON.

		mssql.query('select top 3 * from statusupdates', {
		    success: function(results) {
		        console.log(results);
		    },
            error: function(err) {
                console.log("error is: " + err);
			}
		});


####<a name="dynamic-query"></a>Практическое руководство. Запуск динамического параметризованного запроса

В следующем примере реализуется настраиваемая авторизация путем считывания из таблицы разрешения для каждого пользователя. При выполнении запроса местозаполнитель (?) заменяется предоставленным параметром.

		    var sql = "SELECT _id FROM permissions WHERE userId = ? AND permission = 'submit order'";
		    mssql.query(sql, [user.userId], {
		        success: function(results) {
		            if (results.length > 0) {
		                // Permission record was found. Continue normal execution. 
		                request.execute();
		            } else {
		                console.log('User %s attempted to submit an order without permissions.', user.userId);
		                request.respond(statusCodes.FORBIDDEN, 'You do not have permission to submit orders.');
		            }
		        },
            	error: function(err) {
                	console.log("error is: " + err);
				}	
		    });


####<a name="joins"></a>Практическое руководство. Объединение реляционных таблиц

Можно объединить две таблицы с помощью метода **query** [объекта mssql] для передачи в коде TSQL, который реализует соединение. Предположим, у нас есть некоторые элементы в таблице **ToDoItem**, а каждый элемент в таблице имеет свойство **priority**, которое соответствует столбцу в таблице. Элемент может выглядеть следующим образом:

		{ text: 'Take out the trash', complete: false, priority: 1}

Также предположим, что у нас есть дополнительная таблица, которая называется **Приоритет**, со строками, содержащими **номер** приоритета и текстовое **описание**. Например, номер приоритета 1 может иметь описание "Критический", а объект выглядит следующим образом:

		{ number: 1, description: 'Critical'}

Теперь можно заменить номер **приоритет** в нашем элементе текстовым описанием номера приоритета. Это делается с помощью реляционного соединения двух таблиц.

		mssql.query('SELECT t.text, t.complete, p.description FROM ToDoItem as t INNER JOIN Priority as p ON t.priority = p.number', {
			success: function(results) {
				console.log(results);
			},
            error: function(err) {
                console.log("error is: " + err);
		});
	
Скрипт соединяет две таблицы и записывает результаты в журнал. Полученные объекты могут выглядеть следующим образом:

		{ text: 'Take out the trash', complete: false, description: 'Critical'}


####<a name="raw"></a>Практическое руководство. Выполнение запроса, возвращающего результаты в формате *raw*

В этом примере запрос выполняется, как и раньше, но возвращает результирующий набор в формате "raw", который требуется проанализировать по строкам и по столбцам. Возможный сценарий этого — если вам нужен доступ к типам данных, которые не поддерживают мобильные службы. Этот код просто записывает выходные данные в журнал консоли, так что можно изучить формат raw.

		mssql.queryRaw('SELECT * FROM ToDoItem', {
		    success: function(results) {
		        console.log(results);
		    },
            error: function(err) {
                console.log("error is: " + err);
			}
		});

Здесь представлен результат выполнения данного запроса. Он содержит метаданные о каждом столбце в таблице, за которыми следует представление строк и столбцов.

		{ meta: 
		   [ { name: 'id',
		       size: 19,
		       nullable: false,
		       type: 'number',
		       sqlType: 'bigint identity' },
		     { name: 'text',
		       size: 0,
		       nullable: true,
		       type: 'text',
		       sqlType: 'nvarchar' },
		     { name: 'complete',
		       size: 1,
		       nullable: true,
		       type: 'boolean',
		       sqlType: 'bit' },
		     { name: 'priority',
		       size: 53,
		       nullable: true,
		       type: 'number',
		       sqlType: 'float' } ],
		  rows: 
		   [ [ 1, 'good idea for the future', null, 3 ],
		     [ 2, 'this is important but not so much', null, 2 ],
		     [ 3, 'fix this bug now', null, 0 ],
		     [ 4, 'we need to fix this one real soon now', null, 1 ],
		   ] }

####<a name="connection"></a>Практическое руководство. Доступ для подключения к базе данных

Чтобы получить доступ для подключения к базе данных, можно использовать метод **open**. Одной из причин для этого может быть необходимость использовать транзакции базы данных.

Успешное выполнение **open** вызывает подключение к базе данных, которое передается в функцию **success** в качестве параметра. В объекте **connection** можно вызвать любую из следующих функций: *close*, *queryRaw*, *query*, *beginTransaction*, *commit* и *rollback*.

		    mssql.open({
		        success: function(connection) {
		            connection.query(//query to execute);
		        },
	            error: function(err) {
	                console.log("error is: " + err);
				}
		    });

##<a name="debugging"></a>Отладка и устранение неполадок

Основной способ отладки и устранения неполадок серверных скриптов является запись в журнал службы. По умолчанию мобильные службы записывают ошибки, возникающие во время выполнения скрипта службы, в журналы служб. Ваши скрипты также могут записывать в журналы. Запись в журналы — отличный способ отладить скрипты и проверить, что они ведут себя, как требуется.

###<a name="write-to-logs"></a>Практическое руководство. Запись выходных данных в журналы мобильной службы

Для записи в журналы используется глобальный [консольный объект]. Для записи предупреждений на уровне сведений используются функции **log** или **info**. Функции **warning** и **error** записывают соответствующие уровни, которые вызываются в журналах.

> [AZURE.NOTE] Для просмотра журналов мобильной службы войдите на [классический портал Azure](https://manage.windowsazure.com/), выберите мобильную службу и перейдите на вкладку **Журналы**.

Для форматирования сообщений с помощью параметров можно также использовать функции ведения журнала [консольного объекта]. В следующем примере в качестве параметра в строку сообщения подставляется объект JSON:

	function insert(item, user, request) {
	    console.log("Inserting item '%j' for user '%j'.", item, user);  
	    request.execute();
	}

Обратите внимание, что строка `%j` используется как заполнитель для объекта JSON и что параметры предоставляются последовательно.

Чтобы избежать перегрузки журнала, следует удалить или отключить вызовы console.log(), которые не нужны для работы.

<!-- Anchors. -->
[Introduction]: #intro
[Table operations]: #table-scripts
[Basic table operations]: #basic-table-ops
[Практическое руководство. Регистрация для операций с таблицами]: #register-table-scripts
[How to: Define table scripts]: #execute-operation
[Практическое руководство. Переопределение отклика по умолчанию]: #override-response
[How to: Modify an operation]: #modify-operation
[How to: Override success and error]: #override-success-error
[Практическое руководство. Переопределение успешного выполнения]: #override-success
[Практическое руководство. Переопределение обработки ошибок по умолчанию]: #override-error
[Практическое руководство. Доступ к таблицам из скриптов]: #access-tables
[How to: Add custom parameters]: #access-headers
[Практическое руководство. Добавление пользовательских параметров]: #access-headers
[How to: Work with users]: #work-with-users
[How to: Define scheduled job scripts]: #scheduler-scripts
[How to: Refine access to tables]: #authorize-tables
[Использование языка Transact-SQL для доступа к таблицам]: #TSQL
[Практическое руководство. Запуск статического запроса]: #static-query
[Практическое руководство. Запуск динамического запроса]: #dynamic-query
[Практическое руководство. Выполнение запроса, возвращающего результаты в формате *raw*]: #raw
[Практическое руководство. Доступ для подключения к базе данных]: #connection
[Практическое руководство. Объединение реляционных таблиц]: #joins
[Практическое руководство. Выполнение массовой вставки]: #bulk-inserts
[Практическое руководство. Сопоставление типов JSON с типами баз данных]: #JSON-types
[Практическое руководство. Загрузка модулей Node.js]: #modules-helper-functions
[How to: Write output to the mobile service logs]: #write-to-logs
[Source control, shared code, and helper functions]: #shared-code
[Система управления версиями, общий код и вспомогательные функции]: #shared-code
[Using the command line tool]: #command-prompt
[Использование программы командной строки]: #command-prompt
[Working with tables]: #working-with-tables
[Custom API anchor]: #custom-api
[Практическое руководство. Определение настраиваемого интерфейса API]: #define-custom-api
[How to: Share code by using source control]: #shared-code-source-control
[Практическое руководство. Совместное использование кода с помощью системы управления версиями]: #shared-code-source-control
[Практическое руководство. Использование вспомогательных функций]: #helper-functions
[Debugging and troubleshooting]: #debugging
[Практическое руководство. Реализация методов HTTP]: #handle-methods
[Практическое руководство. Работа с пользователями и заголовками в настраиваемом интерфейсе API]: #get-api-user
[How to: Access custom API request headers]: #get-api-headers
[Job Scheduler]: #scheduler-scripts
[Практическое руководство. Определение нескольких маршрутов настраиваемого интерфейса API]: #api-routes
[Практическое руководство. Отправка и получение данных в формате XML]: #api-return-xml
[Практическое руководство. Работа с параметрами приложения]: #app-settings

[1]: ./media/mobile-services-how-to-use-server-scripts/1-mobile-insert-script-users.png
[2]: ./media/mobile-services-how-to-use-server-scripts/2-mobile-custom-api-script.png
[3]: ./media/mobile-services-how-to-use-server-scripts/3-mobile-schedule-job-script.png
[4]: ./media/mobile-services-how-to-use-server-scripts/4-mobile-source-local-cli.png

<!-- URLs. -->
[Справочник серверных скриптов мобильных служб]: http://msdn.microsoft.com/library/windowsazure/jj554226.aspx
[Планирование заданий сервера в мобильных службах]: /develop/mobile/tutorials/schedule-backend-tasks/
[Планирование серверных заданий в мобильных службах]: /develop/mobile/tutorials/schedule-backend-tasks/
[request object]: http://msdn.microsoft.com/library/windowsazure/jj554218.aspx
[объекта request]: http://msdn.microsoft.com/library/windowsazure/jj554218.aspx
[объекта запроса]: http://msdn.microsoft.com/library/windowsazure/jj554218.aspx
[response object]: http://msdn.microsoft.com/library/windowsazure/dn303373.aspx
[объекта ответа]: http://msdn.microsoft.com/library/windowsazure/dn303373.aspx
[User object]: http://msdn.microsoft.com/library/windowsazure/jj554220.aspx
[объект пользователя]: http://msdn.microsoft.com/library/windowsazure/jj554220.aspx
[объекта USER]: http://msdn.microsoft.com/library/windowsazure/jj554220.aspx
[объекту пользователя]: http://msdn.microsoft.com/library/windowsazure/jj554220.aspx
[push object]: http://msdn.microsoft.com/library/windowsazure/jj554217.aspx
[insert function]: http://msdn.microsoft.com/library/windowsazure/jj554229.aspx
[insert]: http://msdn.microsoft.com/library/windowsazure/jj554229.aspx
[update function]: http://msdn.microsoft.com/library/windowsazure/jj554214.aspx
[delete function]: http://msdn.microsoft.com/library/windowsazure/jj554215.aspx
[read function]: http://msdn.microsoft.com/library/windowsazure/jj554224.aspx
[update]: http://msdn.microsoft.com/library/windowsazure/jj554214.aspx
[delete]: http://msdn.microsoft.com/library/windowsazure/jj554215.aspx
[read]: http://msdn.microsoft.com/library/windowsazure/jj554224.aspx
[query object]: http://msdn.microsoft.com/library/windowsazure/jj613353.aspx
[объект query]: http://msdn.microsoft.com/library/windowsazure/jj613353.aspx
[apns object]: http://msdn.microsoft.com/library/windowsazure/jj839711.aspx
[mpns object]: http://msdn.microsoft.com/library/windowsazure/jj871025.aspx
[wns object]: http://msdn.microsoft.com/library/windowsazure/jj860484.aspx
[table]: http://msdn.microsoft.com/library/windowsazure/jj554210.aspx
[объект таблицы]: http://msdn.microsoft.com/library/windowsazure/jj554210.aspx
[Объект таблицы]: http://msdn.microsoft.com/library/windowsazure/jj554210.aspx
[объекта таблицы]: http://msdn.microsoft.com/library/windowsazure/jj554210.aspx
[объектом таблицы]: http://msdn.microsoft.com/library/windowsazure/jj554210.aspx
[объект таблиц]: http://msdn.microsoft.com/library/windowsazure/jj614364.aspx
[объект таблицы]: http://msdn.microsoft.com/library/windowsazure/jj614364.aspx
[объекта tables]: http://msdn.microsoft.com/library/windowsazure/jj614364.aspx
[объекта таблиц]: http://msdn.microsoft.com/library/windowsazure/jj614364.aspx
[объекту tables]: http://msdn.microsoft.com/library/windowsazure/jj614364.aspx
[объекту таблиц]: http://msdn.microsoft.com/library/windowsazure/jj614364.aspx
[объект mssql]: http://msdn.microsoft.com/library/windowsazure/jj554212.aspx
[объекта mssql]: http://msdn.microsoft.com/library/windowsazure/jj554212.aspx
[объектом mssql]: http://msdn.microsoft.com/library/windowsazure/jj554212.aspx
[консольного объекта]: http://msdn.microsoft.com/library/windowsazure/jj554209.aspx
[консольный объект]: http://msdn.microsoft.com/library/windowsazure/jj554209.aspx
[Чтение и запись данных]: http://msdn.microsoft.com/library/windowsazure/jj631640.aspx
[Проверка данных]: http://msdn.microsoft.com/library/windowsazure/jj631638.aspx
[Изменение запроса]: http://msdn.microsoft.com/library/windowsazure/jj631635.aspx
[Изменение отклика]: http://msdn.microsoft.com/library/windowsazure/jj631631.aspx
[классический портал Azure]: https://manage.windowsazure.com/
[классическом портале Azure]: https://manage.windowsazure.com/
[Расписание заданий]: http://msdn.microsoft.com/library/windowsazure/jj860528.aspx
[Проверка и изменение данных в мобильных службах с помощью серверных скриптов]: /develop/mobile/tutorials/validate-modify-and-augment-data-dotnet/
[Команды для управления мобильными службами Azure]: ../virtual-machines-command-line-tools.md#Mobile_Scripts
[Windows Store Push]: /develop/mobile/tutorials/get-started-with-push-dotnet/
[Windows Phone Push]: /develop/mobile/tutorials/get-started-with-push-wp8/
[iOS Push]: /develop/mobile/tutorials/get-started-with-push-ios/
[Android Push]: /develop/mobile/tutorials/get-started-with-push-android/
[Azure SDK for Node.js]: http://go.microsoft.com/fwlink/p/?LinkId=275539
[Отправка запроса HTTP]: http://msdn.microsoft.com/library/windowsazure/jj631641.aspx
[Отправка электронной почты с мобильных служб с помощью SendGrid]: /develop/mobile/tutorials/send-email-with-sendgrid/
[Приступая к работе с аутентификацией]: http://go.microsoft.com/fwlink/p/?LinkId=287177
[crypto API]: http://go.microsoft.com/fwlink/p/?LinkId=288802
[path API]: http://go.microsoft.com/fwlink/p/?LinkId=288803
[querystring API]: http://go.microsoft.com/fwlink/p/?LinkId=288804
[url API]: http://go.microsoft.com/fwlink/p/?LinkId=288805
[util API]: http://go.microsoft.com/fwlink/p/?LinkId=288806
[zlib API]: http://go.microsoft.com/fwlink/p/?LinkId=288807
[Настраиваемый интерфейс API]: http://msdn.microsoft.com/library/windowsazure/dn280974.aspx
[Вызов настраиваемого API из клиента]: /develop/mobile/tutorials/call-custom-api-dotnet/#define-custom-api
[библиотеки express.js]: http://go.microsoft.com/fwlink/p/?LinkId=309046
[Определение настраиваемого интерфейса API с поддержкой периодических уведомлений]: /develop/mobile/tutorials/create-pull-notifications-dotnet/
[объекту express в express.js]: http://expressjs.com/api.html#express
[Store server scripts in source control]: /develop/mobile/tutorials/store-scripts-in-source-control/
[Использование общего кода и модулей Node.js в серверных скриптах]: /develop/mobile/tutorials/store-scripts-in-source-control/#use-npm
[объект службы]: http://msdn.microsoft.com/library/windowsazure/dn303371.aspx
[Параметры приложения]: http://msdn.microsoft.com/library/dn529070.aspx
[config module]: http://msdn.microsoft.com/library/dn508125.aspx
[Поддержка package.json в мобильных службах Azure]: http://go.microsoft.com/fwlink/p/?LinkId=391036
 

<!---HONumber=AcomDC_0727_2016-->
