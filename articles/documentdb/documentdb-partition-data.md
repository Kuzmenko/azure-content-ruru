<properties 
	pageTitle="Секционирование и масштабирование в Azure DocumentDB | Microsoft Azure"      
	description="Сведения о работе секционирования в Azure DocumentDB, настройке секционирования и ключей секций, а также о выборе подходящего ключа секции для вашего приложения."         
	services="documentdb" 
	authors="arramac" 
	manager="jhubbard" 
	editor="monicar" 
	documentationCenter=""/>

<tags 
	ms.service="documentdb" 
	ms.workload="data-services" 
	ms.tgt_pltfrm="na" 
	ms.devlang="na" 
	ms.topic="article" 
	ms.date="09/20/2016" 
	ms.author="arramac"/>

# Секционирование и масштабирование в Azure DocumentDB
Система [Microsoft Azure DocumentDB](https://azure.microsoft.com/services/documentdb/) разработана таким образом, чтобы обеспечивать высокую и прогнозируемую производительность и легко масштабироваться по мере расширения вашего приложения. В этой статье рассматривается, как работает секционирование в DocumentDB, и описывается, как настроить коллекции DocumentDB для эффективного масштабирования приложений.

После прочтения этой статьи вы сможете ответить на следующие вопросы:

- Как работает секционирование в Azure DocumentDB?
- Как настроить секционирование в DocumentDB
- Что такое ключи секций и как выбрать правильный ключ секции для моего приложения?

Чтобы начать работу с кодом, скачайте проект со страницы [Пример драйвера для тестирования производительности DocumentDB](https://github.com/Azure/azure-documentdb-dotnet/tree/a2d61ddb53f8ab2a23d3ce323c77afcf5a608f52/samples/documentdb-benchmark).

## Секционирование в DocumentDB

В DocumentDB можно хранить документы JSON без схемы и запрашивать их, получая ответ за миллисекунды вне зависимости от масштаба. DocumentDB предоставляет контейнеры для хранения данных, которые называются **коллекциями**. Коллекции — это логические ресурсы, они могут включать в себя одну или несколько физических секций или серверов. Число секций определяется DocumentDB по размеру хранилища и пропускной способности, выделенных для коллекции. С каждой секцией в DocumentDB связано фиксированное хранилище на основе SSD, которое реплицируются для обеспечения высокого уровня доступности. Управление секциями полностью осуществляется Azure DocumentDB, и нет необходимости создавать сложный код или управлять секциями. Коллекции DocumentDB **практически не ограничены** с точки зрения объема хранилища и пропускной способности.

Секционирование полностью прозрачно для вашего приложения. DocumentDB поддерживает быстрое выполнение операций чтения и записи, SQL- и LINQ-запросы, транзакционную логику на основе JavaScript, уровни согласованности и точный контроль доступа благодаря вызовам REST API для отдельных ресурсов коллекции. Служба обрабатывает распределение данных в секциях и направляет запросы в нужную секцию.

Как это работает? При создании коллекции в DocumentDB можно заметить, что существует такое значение конфигурации, как **свойство ключа секции**, которое можно указать. Это свойство JSON (или путь) в документах, которое может использоваться DocumentDB для распределения данных между несколькими серверами или секциями. DocumentDB применит хэш-функцию к ключу секции и использует хэшированный результат, чтобы определить секцию, в которой будет храниться документ JSON. Все документы с одинаковым ключом секции будут храниться в одной секции.

Для примера рассмотрим приложение, которое хранит данные о сотрудниках и их отделах в DocumentDB. Выберем `"department"` в качестве свойства ключа секции, чтобы разворачивать данные по отделам. Каждый документ в DocumentDB должен содержать обязательное свойство `"id"`, которое должно быть уникальным для каждого из документов с одинаковым значением ключа секции, например `"Marketing`. Каждый документ, хранящийся в коллекции, должен иметь уникальное сочетание ключа секции и идентификатора, например `{ "Department": "Marketing", "id": "0001" }`, `{ "Department": "Marketing", "id": "0002" }` и `{ "Department": "Sales", "id": "0001" }`. Другими словами, составное свойство (ключ секции и идентификатор) является первичным ключом для коллекции.

### Ключи секции
Выбор ключа секции — важное решение, которое придется принять на этапе проектирования. Необходимо выбрать имя свойства JSON, предусматривающего широкий диапазон значений и, скорее всего, схемы равномерно распределенного доступа. Ключ секции указывается в виде пути JSON, например `/department` представляет свойство отдела.

В следующей таблице приведены примеры определений для ключей секции и соответствующие значения JSON.

<table border="0" cellspacing="0" cellpadding="0">
    <tbody>
        <tr>
            <td valign="top"><p><strong>Путь к ключу секции</strong></p></td>
            <td valign="top"><p><strong>Описание</strong></p></td>
        </tr>
        <tr>
            <td valign="top"><p>/department</p></td>
            <td valign="top"><p>Соответствует значению JSON doc.department, где "doc" — это документ.</p></td>
        </tr>
        <tr>
            <td valign="top"><p>/properties/name</p></td>
            <td valign="top"><p>Соответствует значению JSON doc.properties.name, где "doc" — это документ (вложенное свойство).</p></td>
        </tr>
        <tr>
            <td valign="top"><p>/id</p></td>
            <td valign="top"><p>Соответствует значению JSON doc.id (идентификатор и ключ секции — это одно и то же свойство).</p></td>
        </tr>
        <tr>
            <td valign="top"><p>/"имя отдела"</p></td>
            <td valign="top"><p>Соответствует значению JSON doc ["имя отдела"], где "doc" — это документ.</p></td>
        </tr>
    </tbody>
</table>

> [AZURE.NOTE] Синтаксис пути к ключу секции аналогичен политике индексации; основное отличие состоит в том, что путь соответствует свойству, а не значению, т. е. в конце нет подстановочного знака. Например, для индексации значений в отделе используется /department/?, а в качестве определения ключа секции — /department. Путь к ключу секции индексируется неявно и не может быть исключен из индексирования с помощью переопределений политики индексирования.

Давайте посмотрим, как выбор ключа секции влияет на производительность приложения.

### Секционирование и подготовленная пропускная способность
Система DocumentDB предназначена для обеспечения прогнозируемой производительности. При создании коллекции вы резервируете пропускную способность в **[единицах запросов](documentdb-request-units.md) в секунду**. На каждый запрос расходуется определенное число единиц запроса, пропорциональное объему системных ресурсов, например ЦП и операций ввода-вывода, потребляемых операцией. Чтение документа размером 1 КБ с согласованностью сеанса потребляет 1 единицу запроса. Чтение является 1 единицей запроса вне зависимости от числа хранящихся элементов или количества параллельных запросов, выполняемых одновременно. Документы большего размера требуют больше единиц запроса. Если вы знаете размер сущностей и количество операций чтения, необходимых для работы вашего приложения, то можете подготовить точную величину пропускной способности, необходимую приложению для операций чтения.

Когда DocumentDB сохраняет документы, они равномерно распределяются между секциями по значению ключа секции. Пропускная способность также распределяется равномерно между доступными секциями, т. е. пропускная способность каждой секции = (общая пропускная способность для коллекции) / (число секций).

>[AZURE.NOTE] Чтобы достичь полной пропускной способности коллекции, необходимо выбрать ключ секции, который позволяет равномерно распределять запросы по нескольким разным значениям ключа секции.

## Односекционные и секционированные коллекции
DocumentDB поддерживает создание односекционных и секционированных коллекций.

- **Секционированные коллекции** могут охватывать несколько секций и поддерживают очень большой объем хранилища и пропускную способность. Для такой коллекции необходимо указать ключ секции.
- **Односекционные коллекции** обладают более низкой ценой и меньшими возможностями для выполнения запросов и транзакций со всеми данными коллекции. Их масштабируемость и размер хранилища ограничены одной секцией. Для таких коллекций не нужно указывать ключ секции.

![Секционированные коллекции в DocumentDB][2]

Для сценариев, не требующих больших объемов хранилища или пропускной способности, подходят односекционные коллекции. Обратите внимание, что возможности масштабирования и хранения данных односекционных коллекций ограничены одной секцией, что составляет до 10 ГБ хранилища и до 10 000 единиц запроса в секунду.

Секционированные коллекции могут поддерживать очень большой объем хранилища и пропускную способность. Однако предложения по умолчанию настроены для хранения до 250 ГБ данных и увеличения масштаба до 250 000 единиц запроса в секунду. Если для коллекции требуется большее хранилище или пропускная способность, обратитесь в [службу поддержки Azure](documentdb-increase-limits.md), чтобы увеличить их для своей учетной записи.

В следующей таблице перечислены различия в работе с односекционными и секционированными коллекциями.

<table border="0" cellspacing="0" cellpadding="0">
    <tbody>
        <tr>
            <td valign="top"><p></p></td>
            <td valign="top"><p><strong>Односекционная коллекция</strong></p></td>
            <td valign="top"><p><strong>Секционированная коллекция</strong></p></td>
        </tr>
        <tr>
            <td valign="top"><p>Ключ раздела</p></td>
            <td valign="top"><p>None</p></td>
            <td valign="top"><p>Обязательно</p></td>
        </tr>
        <tr>
            <td valign="top"><p>Первичный ключ для документа</p></td>
            <td valign="top"><p>идентификатор</p></td>
            <td valign="top"><p>составной ключ: &lt;ключ секции> и идентификатор</p></td>
        </tr>
        <tr>
            <td valign="top"><p>Минимальный объем хранилища</p></td>
            <td valign="top"><p>0 ГБ</p></td>
            <td valign="top"><p>0 ГБ</p></td>
        </tr>
        <tr>
            <td valign="top"><p>Максимальный объем хранилища</p></td>
            <td valign="top"><p>10&#160;ГБ</p></td>
            <td valign="top"><p>Без ограничений (по умолчанию 250 ГБ)</p></td>
        </tr>
        <tr>
            <td valign="top"><p>Минимальная пропускная способность</p></td>
            <td valign="top"><p>400 единиц запроса в секунду</p></td>
            <td valign="top"><p>10 000 единиц запроса в секунду</p></td>
        </tr>
        <tr>
            <td valign="top"><p>Максимальная пропускная способность</p></td>
            <td valign="top"><p>10 000 единиц запроса в секунду</p></td>
            <td valign="top"><p>Без ограничений (по умолчанию 250 000 единиц запроса в секунду)</p></td>
        </tr>
        <tr>
            <td valign="top"><p>Версии API</p></td>
            <td valign="top"><p>Все</p></td>
            <td valign="top"><p>API 2015-12-16 и более поздней версии</p></td>
        </tr>
    </tbody>
</table>

## Работа с пакетами SDK

В Azure DocumentDB добавлена поддержка автоматического секционирования с использованием [REST API версии 2015-12-16](https://msdn.microsoft.com/library/azure/dn781481.aspx). Для создания секционированных коллекций необходимо скачать пакет SDK версии 1.6.0 или более поздней версии для одной из поддерживаемых платформ SDK (.NET, Node.js, Java, Python).

### Создание секционированных коллекций

В приведенном ниже примере показан фрагмент кода .NET для создания коллекции, предназначенной для хранения данных телеметрии устройств, которой выделяется пропускная способность в 20 000 единиц запроса в секунду. Пакет SDK устанавливает значение OfferThroughput (которое в свою очередь задает заголовок запроса `x-ms-offer-throughput` в REST API). Здесь мы задаем `/deviceId` в качестве ключа секции. Выбранный ключ секции сохраняется вместе с остальными метаданными коллекции, такими как имя и политики индексирования.

Для этого примера мы выбрали `deviceId`, т. к. нам известно, что: (а) ввиду большого количества устройств операции записи их можно равномерно распределить между секциями, что позволяет масштабировать базу данных для приема больших объемов данных; (б) многие из запросов, например получение последних показаний устройства, относятся к одному deviceId и могут быть получены из одной секции.

    DocumentClient client = new DocumentClient(new Uri(endpoint), authKey);
    await client.CreateDatabaseAsync(new Database { Id = "db" });

    // Collection for device telemetry. Here the JSON property deviceId will be used as the partition key to 
    // spread across partitions. Configured for 10K RU/s throughput and an indexing policy that supports 
    // sorting against any number or string property.
    DocumentCollection myCollection = new DocumentCollection();
    myCollection.Id = "coll";
    myCollection.PartitionKey.Paths.Add("/deviceId");

    await client.CreateDocumentCollectionAsync(
        UriFactory.CreateDatabaseUri("db"),
        myCollection,
        new RequestOptions { OfferThroughput = 20000 });
        

> [AZURE.NOTE] Для создания секционированных коллекций необходимо указать значение пропускной способности более 10 000 единиц запросов в секунду. Поскольку пропускная способность кратна 100, значение должно составлять 10 100 или более.

Этот метод выполняет вызов REST API в DocumentDB, а служба подготавливает число секций, основываясь на запрошенной пропускной способности. Пропускную способность коллекции можно изменить, когда требуется повысить ее производительность. Дополнительные сведения см. в статье [Уровни производительности](documentdb-performance-levels.md).

### Чтение и запись документов

Пора перейти к вставке данных в DocumentDB. Ниже приведен пример класса, содержащего показание устройства, и вызов CreateDocumentAsync для добавления нового показания устройства в коллекцию.

    public class DeviceReading
    {
        [JsonProperty("id")]
        public string Id;

        [JsonProperty("deviceId")]
        public string DeviceId;

        [JsonConverter(typeof(IsoDateTimeConverter))]
        [JsonProperty("readingTime")]
        public DateTime ReadingTime;

        [JsonProperty("metricType")]
        public string MetricType;

        [JsonProperty("unit")]
        public string Unit;

        [JsonProperty("metricValue")]
        public double MetricValue;
      }

    // Create a document. Here the partition key is extracted as "XMS-0001" based on the collection definition
    await client.CreateDocumentAsync(
        UriFactory.CreateDocumentCollectionUri("db", "coll"),
        new DeviceReading
        {
            Id = "XMS-001-FE24C",
            DeviceId = "XMS-0001",
            MetricType = "Temperature",
            MetricValue = 105.00,
            Unit = "Fahrenheit",
            ReadingTime = DateTime.UtcNow
        });


Давайте прочитаем документ по ключу секции и идентификатору, обновим его, а затем удалим с помощью ключа секции и идентификатора. Обратите внимание, что операции чтения включают в себя значение PartitionKey (соответствующее заголовку запроса `x-ms-documentdb-partitionkey` в REST API).

    // Read document. Needs the partition key and the ID to be specified
    Document result = await client.ReadDocumentAsync(
      UriFactory.CreateDocumentUri("db", "coll", "XMS-001-FE24C"), 
      new RequestOptions { PartitionKey = new PartitionKey("XMS-0001") });

    DeviceReading reading = (DeviceReading)(dynamic)result;

    // Update the document. Partition key is not required, again extracted from the document
    reading.MetricValue = 104;
    reading.ReadingTime = DateTime.UtcNow;

    await client.ReplaceDocumentAsync(
      UriFactory.CreateDocumentUri("db", "coll", "XMS-001-FE24C"), 
      reading);

    // Delete document. Needs partition key
    await client.DeleteDocumentAsync(
      UriFactory.CreateDocumentUri("db", "coll", "XMS-001-FE24C"), 
      new RequestOptions { PartitionKey = new PartitionKey("XMS-0001") });



### Запрос секционированных коллекций

При запросе данных из секционированных коллекций DocumentDB автоматически направляет запрос в секции, соответствующие значению ключа секции, указанному в фильтре (если таковой имеется). Например, этот запрос направляется только в секцию, которая содержит ключ секции XMS-0001.

    // Query using partition key
    IQueryable<DeviceReading> query = client.CreateDocumentQuery<DeviceReading>(
    	UriFactory.CreateDocumentCollectionUri("db", "coll"))
        .Where(m => m.MetricType == "Temperature" && m.DeviceId == "XMS-0001");

Следующий запрос не имеет фильтра ключа секции (DeviceId) и "прочесывает" все секции, где он выполняется с использованием индекса секции. Обратите внимание, что требуется указать EnableCrossPartitionQuery (`x-ms-documentdb-query-enablecrosspartition` в REST API), чтобы пакет SDK выполнил запрос в секциях.

    // Query across partition keys
    IQueryable<DeviceReading> crossPartitionQuery = client.CreateDocumentQuery<DeviceReading>(
        UriFactory.CreateDocumentCollectionUri("db", "coll"), 
        new FeedOptions { EnableCrossPartitionQuery = true })
        .Where(m => m.MetricType == "Temperature" && m.MetricValue > 100);

### Параллельное выполнение запросов

Пакеты SDK для DocumentDB версии 1.9.0 и более поздних версий поддерживают параллельное выполнение запросов, что позволяет выполнять запросы с низким уровнем задержки к секционированным коллекциям, даже если число секций в них очень велико. Например, следующий запрос настроен на выполнение параллельно по секциям.

    // Cross-partition Order By Queries
    IQueryable<DeviceReading> crossPartitionQuery = client.CreateDocumentQuery<DeviceReading>(
        UriFactory.CreateDocumentCollectionUri("db", "coll"), 
        new FeedOptions { EnableCrossPartitionQuery = true, MaxDegreeOfParallelism = 10, MaxBufferedItemCount = 100})
        .Where(m => m.MetricType == "Temperature" && m.MetricValue > 100)
        .OrderBy(m => m.MetricValue);

Вы можете управлять параллельным выполнением запросов, регулируя следующие параметры.

- Параметр `MaxDegreeOfParallelism` позволяет управлять степенью параллелизма, т. е. устанавливать максимальное число одновременных сетевых подключений к секциям коллекции. Если установить значение -1, то степень параллелизма будет регулироваться пакетом SDK. Если параметр `MaxDegreeOfParallelism` не указан или имеет значение 0 (значение по умолчанию), к секциям коллекции будет установлено одно сетевое подключение.
- Параметр `MaxBufferedItemCount` обеспечивает баланс между задержкой запросов и использованием памяти на стороне клиента. Если пропустить этот параметр или задать значение -1, то число буферизованных элементов при параллельном выполнении запросов будет регулироваться пакетом SDK.

При неизменном состоянии коллекции параллельный запрос будет возвращать результаты в том же порядке, что и при последовательном выполнении. При выполнении межсекционного запроса, включающего в себя сортировку (ORDER BY и/или TOP), пакет SDK для DocumentDB параллельно выполняет запрос между секциями и объединяет частично отсортированные результаты на стороне клиента для получения глобально упорядоченных результатов.

### Выполнение хранимых процедур

Также можно выполнять атомарные транзакции с документами с одинаковым идентификатором устройства, т. е. если вы храните статистические выражения или последнее состояние устройства в одном документе.

    await client.ExecuteStoredProcedureAsync<DeviceReading>(
        UriFactory.CreateStoredProcedureUri("db", "coll", "SetLatestStateAcrossReadings"),
        new RequestOptions { PartitionKey = new PartitionKey("XMS-001") }, 
        "XMS-001-FE24C");

В следующем разделе мы рассмотрим переход на секционированные коллекции с односекционных коллекций.

<a name="migrating-from-single-partition"></a>
### Переход с односекционных на секционированные коллекции
Когда приложению, использующему односекционную коллекцию, требуется более высокая пропускная способность (более 10 000 единиц запросов) или хранилище данных большего размера (более 10 ГБ), можно использовать [средство переноса данных DocumentDB](http://www.microsoft.com/downloads/details.aspx?FamilyID=cda7703a-2774-4c07-adcc-ad02ddc1a44d) для переноса данных из односекционной коллекции в секционированную.

Переход с односекционной коллекции на секционированную

1. Экспортируйте данные из односекционной коллекции в JSON. Дополнительные сведения см. в статье [Экспорт в файл JSON](documentdb-import-data.md#export-to-json-file).
2. Импортируйте данные в секционированную коллекцию, созданную с определением ключа секции и пропускной способностью более 10 000 единиц запросов в секунду, как показано в следующем примере. Дополнительные сведения см. в статье [Импорт в DocumentDB](documentdb-import-data.md#DocumentDBSeqTarget).

![Перенос данных в секционированную коллекцию в DocumentDB][3]

>[AZURE.TIP] Для ускорения импорта рекомендуется увеличить количество параллельных запросов до 100 и более, чтобы воспользоваться преимуществами повышенной пропускной способности, доступной для секционированных коллекций.

Теперь, когда мы изучили основы, давайте ознакомимся с несколькими важными рекомендациями по проектированию, касающимися работы с ключами секции в DocumentDB.

## Проектирование секционирования
Выбор ключа секции — важное решение, которое придется принять на этапе проектирования. В этом разделе описываются некоторые компромиссы, имеющие место при выборе ключа секции для коллекции.

### Ключ секции как граница транзакции
Выбранный ключ секции должен сбалансировать необходимость использования транзакций и требование к распределению сущностей по нескольким ключам секции для реализации масштабируемого решения. С одной стороны, можно задать один ключ секции для всех документов, но это может ограничить масштабируемость решения. С другой стороны, можно назначить уникальный ключ секции каждому документу, что обеспечит высокую масштабируемость, но не позволит использовать транзакции между документами с помощью хранимых процедур и триггеров. Идеальный ключ секции позволяет применять эффективные запросы и обеспечивает достаточную кратность, чтобы гарантировать масштабируемость решения.

### Как избежать узких мест хранилища и производительности 
Кроме описанного выше, важно выбрать свойство, которое позволяет распределять операции записи по множеству различных значений. Запросы по одному и тому же ключу секции не могут превышать пропускную способность одной секции, поэтому они будут регулироваться. Поэтому важно выбрать ключ секции, который не создает **"горячие точки"** в вашем приложении. Общий размер хранилища для документов с одинаковым ключом секции также не может превышать 10 ГБ.

### Примеры отличных ключей секции
Вот несколько примеров того, как выбрать ключ секции для приложения.

* Если вы реализуете серверную часть профиля пользователя, то в качестве ключа секции удобно выбрать идентификатор пользователя.
* Если вы храните данные IoT, например состояние устройства, то в качестве ключа секции удобно выбрать идентификатор устройства.
* Если вы используете DocumentDB для ведения журнала данных временных рядов, то в качестве ключа секции удобно выбрать имя узла или идентификатор процесса.
* Если вы используете мультитенантную архитектуру, то в качестве ключа секции удобно выбрать идентификатор клиента.

Обратите внимание, что в некоторых случаях использования (например, IoT и профили пользователей, как описано выше) ключ секции может быть таким же, как и ваш идентификатор (ключ документа). В других случаях, например для данных временных рядов, может потребоваться ключ секции, который отличается от этого идентификатора.

### Секционирование и ведение журнала (данные временных рядов)
Одним из наиболее распространенных вариантов использования DocumentDB является ведение журналов и телеметрия. Важно выбрать подходящий ключ секции, поскольку может понадобиться считывать или записывать огромные объемы данных. Выбор будет зависеть от количества операций чтения и записи, а также типов запросов, которые предполагается выполнять. Ниже приведены некоторые советы по выбору подходящего ключа секции.

- Если ваш вариант использования подразумевает небольшое количество операций записи, накапливаемых в течение длительного срока, а также необходимость запроса по диапазонам меток времени и другим фильтрам, то в качестве ключа секции будет уместно использовать свертку метки времени, например дату. Это позволяет выполнять запросы по всем данным для даты из одной секции.
- Если, как это чаще бывает, рабочая нагрузка подразумевает большое число операций записи, следует использовать ключ секции, который не зависит от метки времени, чтобы DocumentDB мог выполнять равномерную запись в несколько секций. В этом случае хорошим выбором станет имя узла, идентификатор процесса, идентификатор действия или другое свойство с большим количеством элементов.
- Третий подход является гибридным. В нем предусмотрено несколько коллекций — по одной на каждый день и месяц, а ключ секции является фрагментарным свойством, таким как имя узла. Преимущество такого подхода в том, что вы можете задать разные уровни производительности в зависимости от периода. Например, коллекция для текущего месяца подготавливается с более высокой пропускной способностью, так как она обслуживает операции как чтения, так и записи, при этом коллекции за предыдущие месяцы имеют сниженную пропускную способность, так как обслуживают только чтение.

### Секционирование и мультитенантность
Если вы реализуете мультитенантное приложение с помощью DocumentDB, то существует два основных метода реализации механизма аренды с помощью DocumentDB: использовать один ключ секции на клиент или одну коллекцию на клиент. Ниже приведены преимущества и недостатки каждого из методов.

* Один ключ секции на клиент: в этой модели клиенты совместно размещены в одной коллекции. Однако запросы и операции вставки для документов в рамках одного клиента можно выполнить с одной секцией. Кроме того, можно реализовать логику транзакций для всех документов в пределах клиента. Так как несколько клиентов совместно используют одну коллекцию, можно сократить затраты на хранилище и пропускную способность, организовав пул ресурсов для клиентов в пределах одной коллекции, а не подготавливая дополнительный запас для каждого клиента. Недостатком является отсутствие изоляции производительности каждого клиента. Повышение производительности или пропускной способности действует для всей коллекции, а не для выбранных клиентов.
* Одна коллекция на клиент: каждый клиент имеет собственную коллекцию. В этой модели можно резервировать производительность для каждого клиента. Благодаря новой модели ценообразования на основе потребления DocumentDB, эта модель является более экономичной для мультитенантных приложений с небольшим числом клиентов.

Также можно использовать комбинированный или многоуровневый подход, при котором маленькие клиенты размещаются совместно, а большие переносятся в свои собственные коллекции.

## Дальнейшие действия
В этой статье мы рассмотрели, как действует секционирование в Azure DocumentDB, а также узнали, как создать секционированные коллекции и как выбрать подходящий ключ секции для приложения.

-   Выполняйте проверку масштабирования и производительности с помощью DocumentDB. Пример см. в статье [Проверка производительности и масштабирования с помощью Azure DocumentDB](documentdb-performance-testing.md).
-   Приступите к созданию кода с помощью [пакетов SDK](documentdb-sdk-dotnet.md) или [REST API](https://msdn.microsoft.com/library/azure/dn781481.aspx).
-   Узнайте больше о [подготовленной пропускной способности в DocumentDB](documentdb-performance-levels.md).
-   Если вы хотите настроить секционирование, выполняемое приложением, то можете подключить собственную реализацию секционирования на стороне клиента. См. статью [Как секционировать данные с помощью поддержки на стороне клиента в DocumentDB](documentdb-sharding.md).

[1]: ./media/documentdb-partition-data/partitioning.png
[2]: ./media/documentdb-partition-data/single-and-partitioned.png
[3]: ./media/documentdb-partition-data/documentdb-migration-partitioned-collection.png

 

<!---HONumber=AcomDC_0921_2016-->